/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CrossPlayerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// node_modules/sortablejs/modular/sortable.esm.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
var version = "1.15.6";
function userAgent(pattern) {
  if (typeof window !== "undefined" && window.navigator) {
    return !!/* @__PURE__ */ navigator.userAgent.match(pattern);
  }
}
var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
var captureMode = {
  capture: false,
  passive: false
};
function on(el, event, fn) {
  el.addEventListener(event, fn, !IE11OrLess && captureMode);
}
function off(el, event, fn) {
  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}
function matches(el, selector) {
  if (!selector)
    return;
  selector[0] === ">" && (selector = selector.substring(1));
  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }
  return false;
}
function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}
function closest(el, selector, ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;
    do {
      if (selector != null && (selector[0] === ">" ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }
      if (el === ctx)
        break;
    } while (el = getParentOrHost(el));
  }
  return null;
}
var R_SPACE = /\s+/g;
function toggleClass(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? "add" : "remove"](name);
    } else {
      var className = (" " + el.className + " ").replace(R_SPACE, " ").replace(" " + name + " ", " ");
      el.className = (className + (state ? " " + name : "")).replace(R_SPACE, " ");
    }
  }
}
function css(el, prop, val) {
  var style = el && el.style;
  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, "");
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }
      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf("webkit") === -1) {
        prop = "-webkit-" + prop;
      }
      style[prop] = val + (typeof val === "string" ? "" : "px");
    }
  }
}
function matrix(el, selfOnly) {
  var appliedTransforms = "";
  if (typeof el === "string") {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, "transform");
      if (transform && transform !== "none") {
        appliedTransforms = transform + " " + appliedTransforms;
      }
    } while (!selfOnly && (el = el.parentNode));
  }
  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return matrixFn && new matrixFn(appliedTransforms);
}
function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;
    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }
    return list;
  }
  return [];
}
function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;
  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window)
    return;
  var elRect, top, left, bottom, right, height, width;
  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }
  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    container = container || el.parentNode;
    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, "transform") !== "none" || relativeToNonStaticParent && css(container, "position") !== "static")) {
          var containerRect = container.getBoundingClientRect();
          top -= containerRect.top + parseInt(css(container, "border-top-width"));
          left -= containerRect.left + parseInt(css(container, "border-left-width"));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
      } while (container = container.parentNode);
    }
  }
  if (undoScale && el !== window) {
    var elMatrix = matrix(container || el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }
  return {
    top,
    left,
    bottom,
    right,
    width,
    height
  };
}
function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true), elSideVal = getRect(el)[elSide];
  while (parent) {
    var parentSideVal = getRect(parent)[parentSide], visible = void 0;
    if (parentSide === "top" || parentSide === "left") {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }
    if (!visible)
      return parent;
    if (parent === getWindowScrollingElement())
      break;
    parent = getParentAutoScrollElement(parent, false);
  }
  return false;
}
function getChild(el, childNum, options, includeDragEl) {
  var currentChild = 0, i = 0, children = el.children;
  while (i < children.length) {
    if (children[i].style.display !== "none" && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }
      currentChild++;
    }
    i++;
  }
  return null;
}
function lastChild(el, selector) {
  var last = el.lastElementChild;
  while (last && (last === Sortable.ghost || css(last, "display") === "none" || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }
  return last || null;
}
function index(el, selector) {
  var index2 = 0;
  if (!el || !el.parentNode) {
    return -1;
  }
  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== "TEMPLATE" && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index2++;
    }
  }
  return index2;
}
function getRelativeScrollOffset(el) {
  var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
  if (el) {
    do {
      var elMatrix = matrix(el), scaleX = elMatrix.a, scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }
  return [offsetLeft, offsetTop];
}
function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i))
      continue;
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key])
        return Number(i);
    }
  }
  return -1;
}
function getParentAutoScrollElement(el, includeSelf) {
  if (!el || !el.getBoundingClientRect)
    return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;
  do {
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);
      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
        if (!elem.getBoundingClientRect || elem === document.body)
          return getWindowScrollingElement();
        if (gotSelf || includeSelf)
          return elem;
        gotSelf = true;
      }
    }
  } while (elem = elem.parentNode);
  return getWindowScrollingElement();
}
function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }
  return dst;
}
function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
var _throttleTimeout;
function throttle(callback, ms) {
  return function() {
    if (!_throttleTimeout) {
      var args = arguments, _this = this;
      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }
      _throttleTimeout = setTimeout(function() {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}
function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}
function scrollBy(el, x, y) {
  el.scrollLeft += x;
  el.scrollTop += y;
}
function clone(el) {
  var Polymer = window.Polymer;
  var $ = window.jQuery || window.Zepto;
  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($) {
    return $(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}
function getChildContainingRectFromElement(container, options, ghostEl2) {
  var rect = {};
  Array.from(container.children).forEach(function(child) {
    var _rect$left, _rect$top, _rect$right, _rect$bottom;
    if (!closest(child, options.draggable, container, false) || child.animated || child === ghostEl2)
      return;
    var childRect = getRect(child);
    rect.left = Math.min((_rect$left = rect.left) !== null && _rect$left !== void 0 ? _rect$left : Infinity, childRect.left);
    rect.top = Math.min((_rect$top = rect.top) !== null && _rect$top !== void 0 ? _rect$top : Infinity, childRect.top);
    rect.right = Math.max((_rect$right = rect.right) !== null && _rect$right !== void 0 ? _rect$right : -Infinity, childRect.right);
    rect.bottom = Math.max((_rect$bottom = rect.bottom) !== null && _rect$bottom !== void 0 ? _rect$bottom : -Infinity, childRect.bottom);
  });
  rect.width = rect.right - rect.left;
  rect.height = rect.bottom - rect.top;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
var expando = "Sortable" + new Date().getTime();
function AnimationStateManager() {
  var animationStates = [], animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation)
        return;
      var children = [].slice.call(this.el.children);
      children.forEach(function(child) {
        if (css(child, "display") === "none" || child === Sortable.ghost)
          return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });
        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);
          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }
        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;
      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === "function")
          callback();
        return;
      }
      var animating = false, animationTime = 0;
      animationStates.forEach(function(state) {
        var time = 0, target = state.target, fromRect = target.fromRect, toRect = getRect(target), prevFromRect = target.prevFromRect, prevToRect = target.prevToRect, animatingRect = state.rect, targetMatrix = matrix(target, true);
        if (targetMatrix) {
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }
        target.toRect = toRect;
        if (target.thisAnimationDuration) {
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        }
        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;
          if (!time) {
            time = _this.options.animation;
          }
          _this.animate(target, animatingRect, toRect, time);
        }
        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function() {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);
      if (!animating) {
        if (typeof callback === "function")
          callback();
      } else {
        animationCallbackId = setTimeout(function() {
          if (typeof callback === "function")
            callback();
        }, animationTime);
      }
      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, "transition", "");
        css(target, "transform", "");
        var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
        this.forRepaintDummy = repaint(target);
        css(target, "transition", "transform " + duration + "ms" + (this.options.easing ? " " + this.options.easing : ""));
        css(target, "transform", "translate3d(0,0,0)");
        typeof target.animated === "number" && clearTimeout(target.animated);
        target.animated = setTimeout(function() {
          css(target, "transition", "");
          css(target, "transform", "");
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}
function repaint(target) {
  return target.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}
var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    for (var option2 in defaults) {
      if (defaults.hasOwnProperty(option2) && !(option2 in plugin)) {
        plugin[option2] = defaults[option2];
      }
    }
    plugins.forEach(function(p) {
      if (p.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;
    this.eventCanceled = false;
    evt.cancel = function() {
      _this.eventCanceled = true;
    };
    var eventNameGlobal = eventName + "Global";
    plugins.forEach(function(plugin) {
      if (!sortable[plugin.pluginName])
        return;
      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
          sortable
        }, evt));
      }
      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2({
          sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults2, options) {
    plugins.forEach(function(plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault)
        return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized;
      _extends(defaults2, initialized.defaults);
    });
    for (var option2 in sortable.options) {
      if (!sortable.options.hasOwnProperty(option2))
        continue;
      var modified = this.modifyOption(sortable, option2, sortable.options[option2]);
      if (typeof modified !== "undefined") {
        sortable.options[option2] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function(plugin) {
      if (typeof plugin.eventProperties !== "function")
        return;
      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function(plugin) {
      if (!sortable[plugin.pluginName])
        return;
      if (plugin.optionListeners && typeof plugin.optionListeners[name] === "function") {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};
function dispatchEvent(_ref) {
  var sortable = _ref.sortable, rootEl2 = _ref.rootEl, name = _ref.name, targetEl = _ref.targetEl, cloneEl2 = _ref.cloneEl, toEl = _ref.toEl, fromEl = _ref.fromEl, oldIndex2 = _ref.oldIndex, newIndex2 = _ref.newIndex, oldDraggableIndex2 = _ref.oldDraggableIndex, newDraggableIndex2 = _ref.newDraggableIndex, originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl2 && rootEl2[expando];
  if (!sortable)
    return;
  var evt, options = sortable.options, onName = "on" + name.charAt(0).toUpperCase() + name.substr(1);
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent(name, true, true);
  }
  evt.to = toEl || rootEl2;
  evt.from = fromEl || rootEl2;
  evt.item = targetEl || rootEl2;
  evt.clone = cloneEl2;
  evt.oldIndex = oldIndex2;
  evt.newIndex = newIndex2;
  evt.oldDraggableIndex = oldDraggableIndex2;
  evt.newDraggableIndex = newDraggableIndex2;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable2 ? putSortable2.lastPutMode : void 0;
  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
  for (var option2 in allEventProperties) {
    evt[option2] = allEventProperties[option2];
  }
  if (rootEl2) {
    rootEl2.dispatchEvent(evt);
  }
  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}
var _excluded = ["evt"];
var pluginEvent2 = function pluginEvent3(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref.evt, data = _objectWithoutProperties(_ref, _excluded);
  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    dragStarted: moved,
    putSortable,
    activeSortable: Sortable.active,
    originalEvent,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable,
        name,
        originalEvent
      });
    }
  }, data));
};
function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable,
    cloneEl,
    targetEl: dragEl,
    rootEl,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex
  }, info));
}
var dragEl;
var parentEl;
var ghostEl;
var rootEl;
var nextEl;
var lastDownEl;
var cloneEl;
var cloneHidden;
var oldIndex;
var newIndex;
var oldDraggableIndex;
var newDraggableIndex;
var activeGroup;
var putSortable;
var awaitingDragStarted = false;
var ignoreNextClick = false;
var sortables = [];
var tapEvt;
var touchEvt;
var lastDx;
var lastDy;
var tapDistanceLeft;
var tapDistanceTop;
var moved;
var lastTarget;
var lastDirection;
var pastFirstInvertThresh = false;
var isCircumstantialInvert = false;
var targetMoveDistance;
var ghostRelativeParent;
var ghostRelativeParentInitialScroll = [];
var _silent = false;
var savedInputChecked = [];
var documentExists = typeof document !== "undefined";
var PositionGhostAbsolutely = IOS;
var CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float";
var supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div");
var supportCssPointerEvents = function() {
  if (!documentExists)
    return;
  if (IE11OrLess) {
    return false;
  }
  var el = document.createElement("x");
  el.style.cssText = "pointer-events:auto";
  return el.style.pointerEvents === "auto";
}();
var _detectDirection = function _detectDirection2(el, options) {
  var elCSS = css(el), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el, 0, options), child2 = getChild(el, 1, options), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
  if (elCSS.display === "flex") {
    return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  }
  if (elCSS.display === "grid") {
    return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  }
  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
    var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
    return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
  }
  return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
};
var _dragElInRowColumn = function _dragElInRowColumn2(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
};
var _detectNearestEmptySortable = function _detectNearestEmptySortable2(x, y) {
  var ret;
  sortables.some(function(sortable) {
    var threshold = sortable[expando].options.emptyInsertThreshold;
    if (!threshold || lastChild(sortable))
      return;
    var rect = getRect(sortable), insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold, insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;
    if (insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
};
var _prepareGroup = function _prepareGroup2(options) {
  function toFn(value, pull) {
    return function(to, from, dragEl2, evt) {
      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
      if (value == null && (pull || sameGroup)) {
        return true;
      } else if (value == null || value === false) {
        return false;
      } else if (pull && value === "clone") {
        return value;
      } else if (typeof value === "function") {
        return toFn(value(to, from, dragEl2, evt), pull)(to, from, dragEl2, evt);
      } else {
        var otherGroup = (pull ? to : from).options.group.name;
        return value === true || typeof value === "string" && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
      }
    };
  }
  var group = {};
  var originalGroup = options.group;
  if (!originalGroup || _typeof(originalGroup) != "object") {
    originalGroup = {
      name: originalGroup
    };
  }
  group.name = originalGroup.name;
  group.checkPull = toFn(originalGroup.pull, true);
  group.checkPut = toFn(originalGroup.put);
  group.revertClone = originalGroup.revertClone;
  options.group = group;
};
var _hideGhostForTarget = function _hideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "none");
  }
};
var _unhideGhostForTarget = function _unhideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "");
  }
};
if (documentExists && !ChromeForAndroid) {
  document.addEventListener("click", function(evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}
var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent2(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;
    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
    if (nearest) {
      var event = {};
      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }
      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;
      nearest[expando]._onDragOver(event);
    }
  }
};
var _checkOutsideTargetEl = function _checkOutsideTargetEl2(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }
  this.el = el;
  this.options = options = _extends({}, options);
  el[expando] = this;
  var defaults2 = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl2) {
      dataTransfer.setData("Text", dragEl2.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    // Disabled on Safari: #1571; Enabled on Safari IOS: #2244
    supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && (!Safari || IOS),
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults2);
  for (var name in defaults2) {
    !(name in options) && (options[name] = defaults2[name]);
  }
  _prepareGroup(options);
  for (var fn in this) {
    if (fn.charAt(0) === "_" && typeof this[fn] === "function") {
      this[fn] = this[fn].bind(this);
    }
  }
  this.nativeDraggable = options.forceFallback ? false : supportDraggable;
  if (this.nativeDraggable) {
    this.options.touchStartThreshold = 1;
  }
  if (options.supportPointer) {
    on(el, "pointerdown", this._onTapStart);
  } else {
    on(el, "mousedown", this._onTapStart);
    on(el, "touchstart", this._onTapStart);
  }
  if (this.nativeDraggable) {
    on(el, "dragover", this);
    on(el, "dragenter", this);
  }
  sortables.push(this.el);
  options.store && options.store.get && this.sort(options.store.get(this) || []);
  _extends(this, AnimationStateManager());
}
Sortable.prototype = /** @lends Sortable.prototype */
{
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(evt) {
    if (!evt.cancelable)
      return;
    var _this = this, el = this.el, options = this.options, preventOnFilter = options.preventOnFilter, type = evt.type, touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target, filter = options.filter;
    _saveInputCheckedState(el);
    if (dragEl) {
      return;
    }
    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return;
    }
    if (originalTarget.isContentEditable) {
      return;
    }
    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === "SELECT") {
      return;
    }
    target = closest(target, options.draggable, el, false);
    if (target && target.animated) {
      return;
    }
    if (lastDownEl === target) {
      return;
    }
    oldIndex = index(target);
    oldDraggableIndex = index(target, options.draggable);
    if (typeof filter === "function") {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: "filter",
          targetEl: target,
          toEl: el,
          fromEl: el
        });
        pluginEvent2("filter", _this, {
          evt
        });
        preventOnFilter && evt.preventDefault();
        return;
      }
    } else if (filter) {
      filter = filter.split(",").some(function(criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);
        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: "filter",
            targetEl: target,
            fromEl: el,
            toEl: el
          });
          pluginEvent2("filter", _this, {
            evt
          });
          return true;
        }
      });
      if (filter) {
        preventOnFilter && evt.preventDefault();
        return;
      }
    }
    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    }
    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart(evt, touch, target) {
    var _this = this, el = _this.el, options = _this.options, ownerDocument = el.ownerDocument, dragStartFn;
    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style["will-change"] = "all";
      dragStartFn = function dragStartFn2() {
        pluginEvent2("delayEnded", _this, {
          evt
        });
        if (Sortable.eventCanceled) {
          _this._onDrop();
          return;
        }
        _this._disableDelayedDragEvents();
        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        }
        _this._triggerDragStart(evt, touch);
        _dispatchEvent({
          sortable: _this,
          name: "choose",
          originalEvent: evt
        });
        toggleClass(dragEl, options.chosenClass, true);
      };
      options.ignore.split(",").forEach(function(criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
      if (options.supportPointer) {
        on(ownerDocument, "pointerup", _this._onDrop);
        !this.nativeDraggable && on(ownerDocument, "pointercancel", _this._onDrop);
      } else {
        on(ownerDocument, "mouseup", _this._onDrop);
        on(ownerDocument, "touchend", _this._onDrop);
        on(ownerDocument, "touchcancel", _this._onDrop);
      }
      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }
      pluginEvent2("delayStart", this, {
        evt
      });
      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        }
        if (options.supportPointer) {
          on(ownerDocument, "pointerup", _this._disableDelayedDrag);
          on(ownerDocument, "pointercancel", _this._disableDelayedDrag);
        } else {
          on(ownerDocument, "mouseup", _this._disableDelayedDrag);
          on(ownerDocument, "touchend", _this._disableDelayedDrag);
          on(ownerDocument, "touchcancel", _this._disableDelayedDrag);
        }
        on(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
        on(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e) {
    var touch = e.touches ? e.touches[0] : e;
    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);
    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._disableDelayedDrag);
    off(ownerDocument, "touchend", this._disableDelayedDrag);
    off(ownerDocument, "touchcancel", this._disableDelayedDrag);
    off(ownerDocument, "pointerup", this._disableDelayedDrag);
    off(ownerDocument, "pointercancel", this._disableDelayedDrag);
    off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(evt, touch) {
    touch = touch || evt.pointerType == "touch" && evt;
    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, "pointermove", this._onTouchMove);
      } else if (touch) {
        on(document, "touchmove", this._onTouchMove);
      } else {
        on(document, "mousemove", this._onTouchMove);
      }
    } else {
      on(dragEl, "dragend", this);
      on(rootEl, "dragstart", this._onDragStart);
    }
    try {
      if (document.selection) {
        _nextTick(function() {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {
    }
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;
    if (rootEl && dragEl) {
      pluginEvent2("dragStarted", this, {
        evt
      });
      if (this.nativeDraggable) {
        on(document, "dragover", _checkOutsideTargetEl);
      }
      var options = this.options;
      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost();
      _dispatchEvent({
        sortable: this,
        name: "start",
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;
      _hideGhostForTarget();
      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;
      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent)
          break;
        parent = target;
      }
      dragEl.parentNode[expando]._isOutsideThisEl(target);
      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target,
              rootEl: parent
            });
            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }
          target = parent;
        } while (parent = getParentOrHost(parent));
      }
      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(evt) {
    if (tapEvt) {
      var options = this.options, fallbackTolerance = options.fallbackTolerance, fallbackOffset = options.fallbackOffset, touch = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }
        this._onDragStart(evt, true);
      }
      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }
        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, "webkitTransform", cssMatrix);
        css(ghostEl, "mozTransform", cssMatrix);
        css(ghostEl, "msTransform", cssMatrix);
        css(ghostEl, "transform", cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }
      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl, rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options = this.options;
      if (PositionGhostAbsolutely) {
        ghostRelativeParent = container;
        while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }
        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document)
            ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }
        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }
      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, "transition", "");
      css(ghostEl, "transform", "");
      css(ghostEl, "box-sizing", "border-box");
      css(ghostEl, "margin", 0);
      css(ghostEl, "top", rect.top);
      css(ghostEl, "left", rect.left);
      css(ghostEl, "width", rect.width);
      css(ghostEl, "height", rect.height);
      css(ghostEl, "opacity", "0.8");
      css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
      css(ghostEl, "zIndex", "100000");
      css(ghostEl, "pointerEvents", "none");
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl);
      css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
    }
  },
  _onDragStart: function _onDragStart(evt, fallback) {
    var _this = this;
    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent2("dragStart", this, {
      evt
    });
    if (Sortable.eventCanceled) {
      this._onDrop();
      return;
    }
    pluginEvent2("setupClone", this);
    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.removeAttribute("id");
      cloneEl.draggable = false;
      cloneEl.style["will-change"] = "";
      this._hideClone();
      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    }
    _this.cloneId = _nextTick(function() {
      pluginEvent2("clone", _this);
      if (Sortable.eventCanceled)
        return;
      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }
      _this._hideClone();
      _dispatchEvent({
        sortable: _this,
        name: "clone"
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true);
    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      off(document, "mouseup", _this._onDrop);
      off(document, "touchend", _this._onDrop);
      off(document, "touchcancel", _this._onDrop);
      if (dataTransfer) {
        dataTransfer.effectAllowed = "move";
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }
      on(document, "drop", _this);
      css(dragEl, "transform", "translateZ(0)");
    }
    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, "selectstart", _this);
    moved = true;
    window.getSelection().removeAllRanges();
    if (Safari) {
      css(document.body, "user-select", "none");
    }
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function _onDragOver(evt) {
    var el = this.el, target = evt.target, dragRect, targetRect, revert, options = this.options, group = options.group, activeSortable = Sortable.active, isOwner = activeGroup === group, canSort = options.sort, fromSortable = putSortable || activeSortable, vertical, _this = this, completedFired = false;
    if (_silent)
      return;
    function dragOverEvent(name, extra) {
      pluginEvent2(name, _this, _objectSpread2({
        evt,
        isOwner,
        axis: vertical ? "vertical" : "horizontal",
        revert,
        dragRect,
        targetRect,
        canSort,
        fromSortable,
        target,
        completed,
        onMove: function onMove(target2, after2) {
          return _onMove(rootEl, el, dragEl, dragRect, target2, getRect(target2), evt, after2);
        },
        changed
      }, extra));
    }
    function capture() {
      dragOverEvent("dragOverAnimationCapture");
      _this.captureAnimationState();
      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    }
    function completed(insertion) {
      dragOverEvent("dragOverCompleted", {
        insertion
      });
      if (insertion) {
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }
        if (_this !== fromSortable) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }
        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        }
        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }
        _this.animateAll(function() {
          dragOverEvent("dragOverAnimationComplete");
          _this._ignoreWhileAnimating = null;
        });
        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      }
      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      }
      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
        !insertion && nearestEmptyInsertDetectEvent(evt);
      }
      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    }
    function changed() {
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);
      _dispatchEvent({
        sortable: _this,
        name: "change",
        toEl: el,
        newIndex,
        newDraggableIndex,
        originalEvent: evt
      });
    }
    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }
    target = closest(target, options.draggable, el, true);
    dragOverEvent("dragOver");
    if (Sortable.eventCanceled)
      return completedFired;
    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }
    ignoreNextClick = false;
    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === "vertical";
      dragRect = getRect(dragEl);
      dragOverEvent("dragOverValid");
      if (Sortable.eventCanceled)
        return completedFired;
      if (revert) {
        parentEl = rootEl;
        capture();
        this._hideClone();
        dragOverEvent("revert");
        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }
        return completed(true);
      }
      var elLastChild = lastChild(el, options.draggable);
      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        if (elLastChild === dragEl) {
          return completed(false);
        }
        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }
        if (target) {
          targetRect = getRect(target);
        }
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          if (elLastChild && elLastChild.nextSibling) {
            el.insertBefore(dragEl, elLastChild.nextSibling);
          } else {
            el.appendChild(dragEl);
          }
          parentEl = el;
          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        var firstChild = getChild(el, 0, options, true);
        if (firstChild === dragEl) {
          return completed(false);
        }
        target = firstChild;
        targetRect = getRect(target);
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el;
          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }
        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;
        if (direction !== 0) {
          var dragIndex = index(dragEl);
          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
        }
        if (direction === 0 || sibling === target) {
          return completed(false);
        }
        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling, after = false;
        after = direction === 1;
        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }
          _silent = true;
          setTimeout(_unsilent, 30);
          capture();
          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          }
          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }
          parentEl = dragEl.parentNode;
          if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }
          changed();
          return completed(true);
        }
      }
      if (el.contains(dragEl)) {
        return completed(false);
      }
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, "mousemove", this._onTouchMove);
    off(document, "touchmove", this._onTouchMove);
    off(document, "pointermove", this._onTouchMove);
    off(document, "dragover", nearestEmptyInsertDetectEvent);
    off(document, "mousemove", nearestEmptyInsertDetectEvent);
    off(document, "touchmove", nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._onDrop);
    off(ownerDocument, "touchend", this._onDrop);
    off(ownerDocument, "pointerup", this._onDrop);
    off(ownerDocument, "pointercancel", this._onDrop);
    off(ownerDocument, "touchcancel", this._onDrop);
    off(document, "selectstart", this);
  },
  _onDrop: function _onDrop(evt) {
    var el = this.el, options = this.options;
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    pluginEvent2("drop", this, {
      evt
    });
    parentEl = dragEl && dragEl.parentNode;
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    if (Sortable.eventCanceled) {
      this._nulling();
      return;
    }
    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);
    _cancelNextTick(this.cloneId);
    _cancelNextTick(this._dragStartId);
    if (this.nativeDraggable) {
      off(document, "drop", this);
      off(el, "dragstart", this._onDragStart);
    }
    this._offMoveEvents();
    this._offUpEvents();
    if (Safari) {
      css(document.body, "user-select", "");
    }
    css(dragEl, "transform", "");
    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }
      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") {
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }
      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, "dragend", this);
        }
        _disableDraggable(dragEl);
        dragEl.style["will-change"] = "";
        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }
        toggleClass(dragEl, this.options.chosenClass, false);
        _dispatchEvent({
          sortable: this,
          name: "unchoose",
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });
        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            _dispatchEvent({
              rootEl: parentEl,
              name: "add",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "remove",
              toEl: parentEl,
              originalEvent: evt
            });
            _dispatchEvent({
              rootEl: parentEl,
              name: "sort",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "sort",
              toEl: parentEl,
              originalEvent: evt
            });
          }
          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              _dispatchEvent({
                sortable: this,
                name: "update",
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "sort",
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }
        if (Sortable.active) {
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }
          _dispatchEvent({
            sortable: this,
            name: "end",
            toEl: parentEl,
            originalEvent: evt
          });
          this.save();
        }
      }
    }
    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent2("nulling", this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function(el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(evt) {
    switch (evt.type) {
      case "drop":
      case "dragend":
        this._onDrop(evt);
        break;
      case "dragenter":
      case "dragover":
        if (dragEl) {
          this._onDragOver(evt);
          _globalDragOver(evt);
        }
        break;
      case "selectstart":
        evt.preventDefault();
        break;
    }
  },
  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function toArray() {
    var order = [], el, children = this.el.children, i = 0, n = children.length, options = this.options;
    for (; i < n; i++) {
      el = children[i];
      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }
    return order;
  },
  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function sort(order, useAnimation) {
    var items = {}, rootEl2 = this.el;
    this.toArray().forEach(function(id, i) {
      var el = rootEl2.children[i];
      if (closest(el, this.options.draggable, rootEl2, false)) {
        items[id] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order.forEach(function(id) {
      if (items[id]) {
        rootEl2.removeChild(items[id]);
        rootEl2.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },
  /**
   * Save the current sorting
   */
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },
  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },
  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function option(name, value) {
    var options = this.options;
    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);
      if (typeof modifiedValue !== "undefined") {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }
      if (name === "group") {
        _prepareGroup(options);
      }
    }
  },
  /**
   * Destroy
   */
  destroy: function destroy() {
    pluginEvent2("destroy", this);
    var el = this.el;
    el[expando] = null;
    off(el, "mousedown", this._onTapStart);
    off(el, "touchstart", this._onTapStart);
    off(el, "pointerdown", this._onTapStart);
    if (this.nativeDraggable) {
      off(el, "dragover", this);
      off(el, "dragenter", this);
    }
    Array.prototype.forEach.call(el.querySelectorAll("[draggable]"), function(el2) {
      el2.removeAttribute("draggable");
    });
    this._onDrop();
    this._disableDelayedDragEvents();
    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent2("hideClone", this);
      if (Sortable.eventCanceled)
        return;
      css(cloneEl, "display", "none");
      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }
      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable2) {
    if (putSortable2.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (cloneHidden) {
      pluginEvent2("showClone", this);
      if (Sortable.eventCanceled)
        return;
      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }
      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }
      css(cloneEl, "display", "");
      cloneHidden = false;
    }
  }
};
function _globalDragOver(evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = "move";
  }
  evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent("move", {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent("move", true, true);
  }
  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl2;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);
  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }
  return retVal;
}
function _disableDraggable(el) {
  el.draggable = false;
}
function _unsilent() {
  _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
  var firstElRect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
  var spacer = 10;
  return vertical ? evt.clientX < childContainingRect.left - spacer || evt.clientY < firstElRect.top && evt.clientX < firstElRect.right : evt.clientY < childContainingRect.top - spacer || evt.clientY < firstElRect.bottom && evt.clientX < firstElRect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
  var lastElRect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
  var spacer = 10;
  return vertical ? evt.clientX > childContainingRect.right + spacer || evt.clientY > lastElRect.bottom && evt.clientX > lastElRect.left : evt.clientY > childContainingRect.bottom + spacer || evt.clientX > lastElRect.right && evt.clientY > lastElRect.top;
}
function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert = false;
  if (!invertSwap) {
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        pastFirstInvertThresh = true;
      }
      if (!pastFirstInvertThresh) {
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }
  invert = invert || invertSwap;
  if (invert) {
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }
  return 0;
}
function _getInsertDirection(target) {
  if (index(dragEl) < index(target)) {
    return 1;
  } else {
    return -1;
  }
}
function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent, i = str.length, sum = 0;
  while (i--) {
    sum += str.charCodeAt(i);
  }
  return sum.toString(36);
}
function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName("input");
  var idx = inputs.length;
  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}
function _nextTick(fn) {
  return setTimeout(fn, 0);
}
function _cancelNextTick(id) {
  return clearTimeout(id);
}
if (documentExists) {
  on(document, "touchmove", function(evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
}
Sortable.utils = {
  on,
  off,
  css,
  find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend,
  throttle,
  closest,
  toggleClass,
  clone,
  index,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild,
  expando
};
Sortable.get = function(element) {
  return element[expando];
};
Sortable.mount = function() {
  for (var _len = arguments.length, plugins2 = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins2[_key] = arguments[_key];
  }
  if (plugins2[0].constructor === Array)
    plugins2 = plugins2[0];
  plugins2.forEach(function(plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }
    if (plugin.utils)
      Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};
Sortable.create = function(el, options) {
  return new Sortable(el, options);
};
Sortable.version = version;
var autoScrolls = [];
var scrollEl;
var scrollRootEl;
var scrolling = false;
var lastAutoScrollX;
var lastAutoScrollY;
var touchEvt$1;
var pointerElemChangedInterval;
function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };
    for (var fn in this) {
      if (fn.charAt(0) === "_" && typeof this[fn] === "function") {
        this[fn] = this[fn].bind(this);
      }
    }
  }
  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;
      if (this.sortable.nativeDraggable) {
        on(document, "dragover", this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, "pointermove", this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, "touchmove", this._handleFallbackAutoScroll);
        } else {
          on(document, "mousemove", this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop3() {
      if (this.sortable.nativeDraggable) {
        off(document, "dragover", this._handleAutoScroll);
      } else {
        off(document, "pointermove", this._handleFallbackAutoScroll);
        off(document, "touchmove", this._handleFallbackAutoScroll);
        off(document, "mousemove", this._handleFallbackAutoScroll);
      }
      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;
      var x = (evt.touches ? evt.touches[0] : evt).clientX, y = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt;
      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback);
        var ogElemScroller = getParentAutoScrollElement(elem, true);
        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval();
          pointerElemChangedInterval = setInterval(function() {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);
            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }
            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }
        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: "scroll",
    initializeByDefault: true
  });
}
function clearAutoScrolls() {
  autoScrolls.forEach(function(autoScroll2) {
    clearInterval(autoScroll2.pid);
  });
  autoScrolls = [];
}
function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}
var autoScroll = throttle(function(evt, options, rootEl2, isFallback) {
  if (!options.scroll)
    return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX, y = (evt.touches ? evt.touches[0] : evt).clientY, sens = options.scrollSensitivity, speed = options.scrollSpeed, winScroller = getWindowScrollingElement();
  var scrollThisInstance = false, scrollCustomFn;
  if (scrollRootEl !== rootEl2) {
    scrollRootEl = rootEl2;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;
    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl2, true);
    }
  }
  var layersOut = 0;
  var currentParent = scrollEl;
  do {
    var el = currentParent, rect = getRect(el), top = rect.top, bottom = rect.bottom, left = rect.left, right = rect.right, width = rect.width, height = rect.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el.scrollWidth, scrollHeight = el.scrollHeight, elCSS = css(el), scrollPosX = el.scrollLeft, scrollPosY = el.scrollTop;
    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
    }
    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);
    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }
    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);
      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        autoScrolls[layersOut].pid = setInterval(function() {
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1);
          }
          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
          if (typeof scrollCustomFn === "function") {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") {
              return;
            }
          }
          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }
    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
  scrolling = scrollThisInstance;
}, 30);
var drop = function drop2(_ref) {
  var originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, dragEl2 = _ref.dragEl, activeSortable = _ref.activeSortable, dispatchSortableEvent = _ref.dispatchSortableEvent, hideGhostForTarget = _ref.hideGhostForTarget, unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent)
    return;
  var toSortable = putSortable2 || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();
  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent("spill");
    this.onSpill({
      dragEl: dragEl2,
      putSortable: putSortable2
    });
  }
};
function Revert() {
}
Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex2 = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex2;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl2 = _ref3.dragEl, putSortable2 = _ref3.putSortable;
    this.sortable.captureAnimationState();
    if (putSortable2) {
      putSortable2.captureAnimationState();
    }
    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl2, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl2);
    }
    this.sortable.animateAll();
    if (putSortable2) {
      putSortable2.animateAll();
    }
  },
  drop
};
_extends(Revert, {
  pluginName: "revertOnSpill"
});
function Remove() {
}
Remove.prototype = {
  onSpill: function onSpill2(_ref4) {
    var dragEl2 = _ref4.dragEl, putSortable2 = _ref4.putSortable;
    var parentSortable = putSortable2 || this.sortable;
    parentSortable.captureAnimationState();
    dragEl2.parentNode && dragEl2.parentNode.removeChild(dragEl2);
    parentSortable.animateAll();
  },
  drop
};
_extends(Remove, {
  pluginName: "removeOnSpill"
});
Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);
var sortable_esm_default = Sortable;

// src/main.ts
var VIEW_TYPE_CROSS_PLAYER_LIST = "cross-player-list-view";
var VIEW_TYPE_CROSS_PLAYER_MAIN = "cross-player-main-view";
var DEFAULT_SETTINGS = {
  watchedFolder: "",
  defaultPlaybackSpeed: 2,
  seekSecondsForward: 10,
  seekSecondsBackward: 10,
  youtubeDlpPath: "yt-dlp",
  ffmpegPath: "",
  downloadFolder: "",
  showMediaIndicator: true,
  storageLimitGB: 10,
  autoplayNext: true,
  showProgressColor: true,
  pauseOnMobileTap: true
};
var CrossPlayerPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    // No more fs watcher, we use Obsidian events
    this.listView = null;
    this.mainView = null;
    this.activeDownloads = [];
    this.fsWatcher = null;
    this.deviceId = "";
    this.deviceName = "";
    this.dynamicStorageLimit = 0;
    // bytes
    this.limitingDevice = "";
  }
  async onload() {
    await this.loadData();
    this.calculateDynamicLimit();
    this.debouncedUpdateDeviceStatus = (0, import_obsidian.debounce)(async () => {
      await this.updateDeviceStatus();
    }, 2e3, true);
    this.addCommand({
      id: "test-yt-dlp",
      name: "Test yt-dlp Configuration",
      callback: async () => {
        if (!import_obsidian.Platform.isDesktop) {
          new import_obsidian.Notice("This command is only available on Desktop.");
          return;
        }
        const { youtubeDlpPath } = this.data.settings;
        const ytPath = youtubeDlpPath.trim();
        new import_obsidian.Notice(`Testing yt-dlp at: ${ytPath}`);
        try {
          const { spawn } = require("child_process");
          const child = spawn(ytPath, ["--version"]);
          child.stdout.on("data", (data) => {
            const version2 = data.toString().trim();
            new import_obsidian.Notice(`yt-dlp version: ${version2}`);
            if (version2.startsWith("2021") || version2.startsWith("2022") || version2.startsWith("2023")) {
              new import_obsidian.Notice("\u26A0\uFE0F Your yt-dlp is very old! Please update it.");
            }
          });
          child.stderr.on("data", (data) => {
            new import_obsidian.Notice(`yt-dlp error: ${data.toString()}`);
          });
          child.on("error", (err) => {
            new import_obsidian.Notice(`Failed to run yt-dlp: ${err.message}`);
          });
          const { ffmpegPath } = this.data.settings;
          if (ffmpegPath) {
            const ffmpegChild = spawn(ffmpegPath, ["-version"]);
            ffmpegChild.on("error", () => {
              new import_obsidian.Notice(`\u26A0\uFE0F FFmpeg not found at: ${ffmpegPath}`);
            });
            ffmpegChild.stdout.on("data", (data) => {
              if (data.toString().includes("ffmpeg version")) {
              }
            });
          }
        } catch (e) {
          new import_obsidian.Notice(`Exception: ${e.message}`);
        }
      }
    });
    this.addSettingTab(new CrossPlayerSettingTab(this.app, this));
    this.registerView(
      VIEW_TYPE_CROSS_PLAYER_LIST,
      (leaf) => this.listView = new CrossPlayerListView(leaf, this)
    );
    this.registerView(
      VIEW_TYPE_CROSS_PLAYER_MAIN,
      (leaf) => this.mainView = new CrossPlayerMainView(leaf, this)
    );
    this.addRibbonIcon("play-circle", "Open Cross Player", () => {
      this.activateListView();
    });
    this.addCommand({
      id: "clean-consumed-media",
      name: "Clean Consumed Media",
      callback: () => this.cleanConsumedMedia()
    });
    this.addCommand({
      id: "open-cross-player",
      name: "Open Cross Player",
      callback: () => {
        this.activateListView();
      }
    });
    this.addCommand({
      id: "set-watched-folder",
      name: "Set Watched Folder",
      callback: () => {
        new FolderSuggestModal(this.app, this).open();
      }
    });
    this.addCommand({
      id: "increase-playback-speed",
      name: "Increase Playback Speed",
      callback: () => {
        if (this.mainView)
          this.mainView.changePlaybackSpeed(0.1);
      }
    });
    this.addCommand({
      id: "decrease-playback-speed",
      name: "Decrease Playback Speed",
      callback: () => {
        if (this.mainView)
          this.mainView.changePlaybackSpeed(-0.1);
      }
    });
    this.addCommand({
      id: "seek-forward",
      name: "Seek Forward",
      callback: () => {
        if (this.mainView) {
          this.mainView.seek(this.data.settings.seekSecondsForward);
        }
      }
    });
    this.addCommand({
      id: "seek-backward",
      name: "Seek Backward",
      callback: () => {
        if (this.mainView) {
          this.mainView.seek(-this.data.settings.seekSecondsBackward);
        }
      }
    });
    this.addCommand({
      id: "delete-current-file",
      name: "Delete Current File",
      callback: () => this.deleteCurrentFile()
    });
    this.addCommand({
      id: "play-next-file",
      name: "Go to Next File",
      callback: () => this.playNextItem()
    });
    this.addCommand({
      id: "play-previous-file",
      name: "Go to Previous File",
      callback: () => this.playPreviousItem()
    });
    this.addCommand({
      id: "set-current-unread",
      name: "Set Current File as Unread",
      callback: () => this.setCurrentAsUnread()
    });
    this.addCommand({
      id: "refresh-watched-folder",
      name: "Refresh Watched Folder",
      callback: () => {
        if (this.data.settings.watchedFolder) {
          this.scanFolder(this.data.settings.watchedFolder);
          new import_obsidian.Notice("Watched folder refreshed.");
        } else {
          new import_obsidian.Notice("No watched folder set.");
        }
      }
    });
    this.addCommand({
      id: "download-youtube-video",
      name: "Download YouTube Video",
      callback: () => {
        new YouTubeDownloadModal(this.app, this).open();
      }
    });
    this.addCommand({
      id: "reload-data",
      name: "Reload Data from Disk",
      callback: async () => {
        await this.loadData();
        if (this.listView)
          this.listView.refresh();
        new import_obsidian.Notice("Data reloaded.");
      }
    });
    this.addCommand({
      id: "toggle-fullscreen",
      name: "Toggle Fullscreen",
      callback: () => {
        if (this.mainView) {
          this.mainView.toggleFullscreen();
        } else {
          new import_obsidian.Notice("Open a media file first.");
        }
      }
    });
    if (import_obsidian.Platform.isDesktop) {
      this.debouncedReload = (0, import_obsidian.debounce)(async () => {
        await this.loadData();
        if (this.listView)
          this.listView.refresh();
      }, 1e3, true);
      try {
        const path = require("path");
        const fs = require("fs");
        if (this.app.vault.adapter && this.app.vault.adapter.getBasePath) {
          const basePath = this.app.vault.adapter.getBasePath();
          const dataPath = path.join(basePath, this.manifest.dir, "data.json");
          if (fs.existsSync(dataPath)) {
            this.fsWatcher = fs.watch(dataPath, (eventType) => {
              if (eventType === "change") {
                this.debouncedReload();
              }
            });
          }
        }
      } catch (e) {
        console.error("Failed to setup data watcher", e);
      }
    }
    this.registerWatchers();
    if (this.data.settings.watchedFolder) {
      this.scanFolder(this.data.settings.watchedFolder);
    }
    await this.loadDeviceId();
    this.updateDeviceStatus();
  }
  onunload() {
    if (this.fsWatcher) {
      this.fsWatcher.close();
      this.fsWatcher = null;
    }
  }
  async loadDeviceId() {
    let id = localStorage.getItem("cross-player-device-id");
    if (!id) {
      id = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
      localStorage.setItem("cross-player-device-id", id);
    }
    this.deviceId = id;
    let name = import_obsidian.Platform.isMobile ? "Mobile" : "Desktop";
    if (import_obsidian.Platform.isDesktop) {
      try {
        const os = require("os");
        name = os.hostname();
      } catch (e) {
      }
    } else {
      if (import_obsidian.Platform.isIosApp)
        name = "iPad/iPhone";
      if (import_obsidian.Platform.isAndroidApp)
        name = "Android";
    }
    this.deviceName = name;
  }
  async getFreeSpace() {
    if (navigator.storage && navigator.storage.estimate) {
      try {
        const estimate = await navigator.storage.estimate();
        if (estimate.quota && estimate.usage !== void 0) {
          return estimate.quota - estimate.usage;
        }
      } catch (e) {
        console.error("Storage estimate failed", e);
      }
    }
    return 10 * 1024 * 1024 * 1024;
  }
  async updateDeviceStatus() {
    if (!this.deviceId)
      await this.loadDeviceId();
    const freeSpace = await this.getFreeSpace();
    const status = {
      id: this.deviceId,
      name: this.deviceName,
      freeSpace,
      timestamp: Date.now()
    };
    const watchedFolder = this.data.settings.watchedFolder;
    if (!watchedFolder)
      return;
    const devicesDir = watchedFolder + "/.cross-player-devices";
    try {
      if (!await this.app.vault.adapter.exists(devicesDir)) {
        await this.app.vault.createFolder(devicesDir);
      }
      const filePath = `${devicesDir}/${this.deviceId}.json`;
      await this.app.vault.adapter.write(filePath, JSON.stringify(status, null, 2));
      await this.calculateDynamicLimit();
    } catch (e) {
      console.error("Failed to update device status", e);
    }
  }
  async calculateDynamicLimit() {
    const limitGB = this.data.settings.storageLimitGB || 10;
    this.dynamicStorageLimit = limitGB * 1024 * 1024 * 1024;
    this.limitingDevice = "Manual Setting";
    if (this.listView)
      this.listView.refresh();
  }
  async loadData() {
    const loaded = await super.loadData();
    const settings = Object.assign({}, DEFAULT_SETTINGS, loaded ? loaded.settings : {});
    this.data = Object.assign({
      settings,
      queue: [],
      // Initialize playbackSpeed with default if not present
      playbackSpeed: settings.defaultPlaybackSpeed
    }, loaded);
    this.data.settings = settings;
  }
  async saveData() {
    await super.saveData(this.data);
    if (this.listView)
      this.listView.refresh();
  }
  registerWatchers() {
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        this.handleFileChange(file);
        this.debouncedUpdateDeviceStatus();
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", (file, oldPath) => {
        this.handleRename(file, oldPath);
      })
    );
    this.registerEvent(
      this.app.vault.on("delete", (file) => {
        this.handleDelete(file);
        this.debouncedUpdateDeviceStatus();
      })
    );
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        const watchedFolder = this.data.settings.watchedFolder;
        if (watchedFolder && file.path.startsWith(watchedFolder + "/.cross-player-devices/")) {
          this.calculateDynamicLimit();
        }
      })
    );
  }
  async setWatchedFolder(path) {
    this.data.settings.watchedFolder = path;
    await this.saveData();
    new import_obsidian.Notice(`Watched folder set to: ${path}`);
    this.scanFolder(path);
  }
  async scanFolder(folderPath) {
    const folder = this.app.vault.getAbstractFileByPath(folderPath);
    if (folder instanceof import_obsidian.TFolder) {
      const files = this.app.vault.getFiles();
      const filesInFolder = files.filter((file) => file.path.startsWith(folderPath + "/"));
      const promises = filesInFolder.map((file) => this.handleFileChange(file, false));
      await Promise.all(promises);
      await this.saveData();
    } else {
      console.warn("Watched path is not a folder:", folderPath);
    }
  }
  async getMediaDuration(file) {
    return new Promise((resolve) => {
      const video = document.createElement("video");
      video.preload = "metadata";
      video.onloadedmetadata = () => {
        resolve(video.duration);
        video.remove();
      };
      video.onerror = () => {
        resolve(0);
        video.remove();
      };
      video.src = this.app.vault.getResourcePath(file);
    });
  }
  getQueueStats() {
    let totalDuration = 0;
    let totalSize = 0;
    for (const item of this.data.queue) {
      const file = this.app.vault.getAbstractFileByPath(item.path);
      if (file instanceof import_obsidian.TFile) {
        totalSize += file.stat.size;
      } else if (item.size) {
        totalSize += item.size;
      }
      if (item.status === "pending" || item.status === "playing") {
        const position = item.position || 0;
        totalDuration += Math.max(0, item.duration - position);
      }
    }
    return { totalDuration, totalSize };
  }
  async handleRename(file, oldPath) {
    const queue = this.data.queue;
    const itemsToUpdate = queue.filter((item) => item.path === oldPath || item.path.startsWith(oldPath + "/"));
    if (itemsToUpdate.length > 0) {
      for (const item of itemsToUpdate) {
        const newPath = item.path.replace(oldPath, file.path);
        item.path = newPath;
        const watchedFolder2 = this.data.settings.watchedFolder;
        if (watchedFolder2 && !newPath.startsWith(watchedFolder2 + "/") && newPath !== watchedFolder2) {
          item.status = "completed";
        }
      }
      const watchedFolder = this.data.settings.watchedFolder;
      if (watchedFolder) {
        this.data.queue = this.data.queue.filter((item) => {
          return item.path.startsWith(watchedFolder + "/") || item.path === watchedFolder;
        });
      }
      await this.saveData();
    }
    this.handleFileChange(file);
  }
  async handleDelete(file) {
    const path = file.path;
    const initialLength = this.data.queue.length;
    this.data.queue = this.data.queue.filter((item) => item.path !== path && !item.path.startsWith(path + "/"));
    if (this.data.queue.length !== initialLength) {
      await this.saveData();
    }
  }
  async handleFileChange(file, shouldSave = true) {
    const folderPath = this.data.settings.watchedFolder;
    if (!folderPath)
      return;
    if (file.name.startsWith(".") || file.path.includes("/."))
      return;
    if (file instanceof import_obsidian.TFolder) {
      for (const child of file.children) {
        await this.handleFileChange(child, shouldSave);
      }
      return;
    }
    if (!(file instanceof import_obsidian.TFile))
      return;
    if (!file.path.startsWith(folderPath + "/"))
      return;
    const ext = file.extension.toLowerCase();
    const validExtensions = ["mp4", "webm", "ogv", "mp3", "wav", "ogg", "mkv"];
    if (!validExtensions.includes(ext))
      return;
    const existing = this.data.queue.find((item) => item.path === file.path);
    if (!existing) {
      const duration = await this.getMediaDuration(file);
      const newItem = {
        id: Math.random().toString(36).substring(2, 11),
        path: file.path,
        // Store vault relative path
        name: file.name,
        status: "pending",
        position: 0,
        duration,
        size: file.stat.size
      };
      this.data.queue.push(newItem);
      if (shouldSave) {
        await this.saveData();
        new import_obsidian.Notice(`Added ${file.name} to queue`);
      }
    } else {
      let changed = false;
      if (!existing.duration) {
        existing.duration = await this.getMediaDuration(file);
        changed = true;
      }
      if (!existing.size) {
        existing.size = file.stat.size;
        changed = true;
      }
      if (changed && shouldSave)
        await this.saveData();
    }
  }
  async activateListView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_CROSS_PLAYER_LIST);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getLeftLeaf(false);
      await leaf.setViewState({ type: VIEW_TYPE_CROSS_PLAYER_LIST, active: true });
    }
    workspace.revealLeaf(leaf);
  }
  async activateMainView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_CROSS_PLAYER_MAIN);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getLeaf(false);
      await leaf.setViewState({ type: VIEW_TYPE_CROSS_PLAYER_MAIN, active: true });
    }
    workspace.revealLeaf(leaf);
    workspace.setActiveLeaf(leaf, { focus: true });
    if (leaf.view instanceof CrossPlayerMainView) {
      this.mainView = leaf.view;
      setTimeout(() => {
        if (this.mainView) {
          this.mainView.contentEl.focus();
          if (this.mainView.videoEl) {
            this.mainView.videoEl.focus();
          }
        }
      }, 100);
    }
  }
  async playMedia(item, autoPlay = false) {
    await this.activateMainView();
    const currentPlaying = this.data.queue.find((i) => i.status === "playing");
    if (currentPlaying && currentPlaying.id !== item.id) {
      if (currentPlaying.finished) {
        currentPlaying.status = "completed";
      } else {
        currentPlaying.status = "pending";
      }
    }
    if (item.status === "completed") {
      item.finished = true;
    }
    item.status = "playing";
    await this.saveData();
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_CROSS_PLAYER_MAIN);
    if (leaves.length > 0 && leaves[0].view instanceof CrossPlayerMainView) {
      leaves[0].view.play(item, autoPlay);
    }
  }
  async playNextUnread() {
    let currentIndex = -1;
    if (this.mainView && this.mainView.currentItem) {
      currentIndex = this.data.queue.findIndex((i) => i.id === this.mainView.currentItem.id);
    }
    if (currentIndex === -1) {
      currentIndex = this.data.queue.findIndex((i) => i.status === "playing");
    }
    const nextItem = this.data.queue.find((item, index2) => index2 > currentIndex && item.status === "pending");
    if (nextItem) {
      this.playMedia(nextItem, true);
    }
  }
  async playNextItem() {
    let currentIndex = -1;
    if (this.mainView && this.mainView.currentItem) {
      currentIndex = this.data.queue.findIndex((i) => i.id === this.mainView.currentItem.id);
    }
    const nextIndex = currentIndex + 1;
    if (nextIndex < this.data.queue.length) {
      this.playMedia(this.data.queue[nextIndex], true);
    }
  }
  async playPreviousItem() {
    let currentIndex = -1;
    if (this.mainView && this.mainView.currentItem) {
      currentIndex = this.data.queue.findIndex((i) => i.id === this.mainView.currentItem.id);
    }
    if (currentIndex === -1)
      return;
    const prevIndex = currentIndex - 1;
    if (prevIndex >= 0) {
      this.playMedia(this.data.queue[prevIndex], true);
    }
  }
  async updateStatus(id, status) {
    const item = this.data.queue.find((i) => i.id === id);
    if (item) {
      item.status = status;
      if (status === "completed") {
        item.finished = true;
      }
      await this.saveData();
    }
  }
  async updatePosition(id, position) {
    const item = this.data.queue.find((i) => i.id === id);
    if (item) {
      item.position = position;
      await this.saveData();
    }
  }
  async moveItem(index2, direction) {
    const newIndex2 = index2 + direction;
    if (newIndex2 < 0 || newIndex2 >= this.data.queue.length)
      return;
    const item = this.data.queue[index2];
    this.data.queue.splice(index2, 1);
    this.data.queue.splice(newIndex2, 0, item);
    await this.saveData();
  }
  async reorderItem(oldIndex2, newIndex2) {
    if (oldIndex2 < 0 || oldIndex2 >= this.data.queue.length || newIndex2 < 0 || newIndex2 >= this.data.queue.length)
      return;
    const item = this.data.queue[oldIndex2];
    this.data.queue.splice(oldIndex2, 1);
    this.data.queue.splice(newIndex2, 0, item);
    await this.saveData();
  }
  async sortQueue(by, order) {
    this.data.queue.sort((a, b) => {
      var _a, _b;
      let valA = a.name;
      let valB = b.name;
      if (by === "type") {
        valA = ((_a = a.path.split(".").pop()) == null ? void 0 : _a.toLowerCase()) || "";
        valB = ((_b = b.path.split(".").pop()) == null ? void 0 : _b.toLowerCase()) || "";
      } else if (by === "size") {
        valA = a.size || 0;
        valB = b.size || 0;
      } else {
        valA = a.name.toLowerCase();
        valB = b.name.toLowerCase();
      }
      if (valA < valB)
        return order === "asc" ? -1 : 1;
      if (valA > valB)
        return order === "asc" ? 1 : -1;
      return 0;
    });
    await this.saveData();
  }
  async cleanConsumedMedia() {
    const toRemove = this.data.queue.filter((item) => item.status === "completed");
    if (toRemove.length === 0) {
      new import_obsidian.Notice("No completed media to clean.");
      return;
    }
    let count = 0;
    for (const item of toRemove) {
      try {
        const file = this.app.vault.getAbstractFileByPath(item.path);
        if (file instanceof import_obsidian.TFile) {
          await this.app.vault.trash(file, true);
          count++;
        }
      } catch (e) {
        console.error("Failed to delete", item.path, e);
      }
    }
    this.data.queue = this.data.queue.filter((item) => item.status !== "completed");
    await this.saveData();
    new import_obsidian.Notice(`Cleaned ${count} media files.`);
  }
  async deleteMediaItem(item) {
    const isCurrent = this.mainView && this.mainView.currentItem && this.mainView.currentItem.id === item.id;
    if (isCurrent && this.mainView) {
      this.mainView.videoEl.pause();
    }
    try {
      const file = this.app.vault.getAbstractFileByPath(item.path);
      if (file instanceof import_obsidian.TFile) {
        await this.app.vault.trash(file, true);
      }
    } catch (e) {
      console.error("Error deleting file:", e);
      new import_obsidian.Notice("Error deleting file.");
    }
    let nextItem;
    if (isCurrent) {
      const currentIndex = this.data.queue.findIndex((i) => i.id === item.id);
      nextItem = this.data.queue.find((i, index2) => index2 > currentIndex && i.status === "pending");
    }
    this.data.queue = this.data.queue.filter((i) => i.id !== item.id);
    await this.saveData();
    new import_obsidian.Notice(`Deleted: ${item.name}`);
    if (isCurrent) {
      if (nextItem) {
        await this.playMedia(nextItem, true);
      } else {
        if (this.mainView) {
          this.mainView.currentItem = null;
          this.mainView.videoEl.src = "";
        }
        this.activateListView();
      }
    }
  }
  async deleteCurrentFile() {
    if (!this.mainView || !this.mainView.currentItem) {
      new import_obsidian.Notice("No active media to delete.");
      return;
    }
    await this.deleteMediaItem(this.mainView.currentItem);
  }
  async setMediaItemAsUnread(item) {
    const queueItem = this.data.queue.find((i) => i.id === item.id);
    if (!queueItem) {
      new import_obsidian.Notice("Item not found in queue.");
      return;
    }
    const isCurrent = this.mainView && this.mainView.currentItem && this.mainView.currentItem.id === item.id;
    if (isCurrent && this.mainView) {
      this.mainView.currentItem = null;
      this.mainView.videoEl.pause();
      this.mainView.videoEl.src = "";
      this.activateListView();
    }
    queueItem.status = "pending";
    queueItem.finished = false;
    queueItem.position = 0;
    await this.saveData();
    if (this.listView) {
      this.listView.refresh();
    }
    new import_obsidian.Notice(`Marked as unread: ${queueItem.name}`);
  }
  async setCurrentAsUnread() {
    if (!this.mainView || !this.mainView.currentItem) {
      new import_obsidian.Notice("No active media.");
      return;
    }
    await this.setMediaItemAsUnread(this.mainView.currentItem);
  }
  async downloadVideos(links, quality, type) {
    if (!import_obsidian.Platform.isDesktop) {
      new import_obsidian.Notice("Downloading is only supported on Desktop.");
      return;
    }
    const { youtubeDlpPath, downloadFolder, watchedFolder } = this.data.settings;
    const targetFolder = downloadFolder || watchedFolder;
    if (!targetFolder) {
      new import_obsidian.Notice("Please set a download folder or watched folder first.");
      return;
    }
    const path = require("path");
    const fs = require("fs");
    const adapter = this.app.vault.adapter;
    let absolutePath;
    if (adapter instanceof Object && "getBasePath" in adapter) {
      absolutePath = path.join(adapter.getBasePath(), targetFolder);
    } else {
      new import_obsidian.Notice("Could not resolve absolute path for vault.");
      return;
    }
    if (!fs.existsSync(absolutePath)) {
      new import_obsidian.Notice(`Target folder does not exist: ${targetFolder}`);
      return;
    }
    const ytPath = youtubeDlpPath.trim();
    if (ytPath !== "yt-dlp" && !fs.existsSync(ytPath)) {
      new import_obsidian.Notice(`yt-dlp binary not found at: ${ytPath}`);
      return;
    }
    new import_obsidian.Notice(`Starting download of ${links.length} items...`);
    for (const link of links) {
      if (!link.trim())
        continue;
      this.startDownload(link.trim(), quality, type, absolutePath);
    }
  }
  async startDownload(link, quality, type, cwd, existingId) {
    var _a, _b;
    if (!import_obsidian.Platform.isDesktop)
      return;
    const { youtubeDlpPath, ffmpegPath } = this.data.settings;
    const ytPath = youtubeDlpPath.trim();
    const downloadId = existingId || Math.random().toString(36).substring(7);
    let downloadStatus;
    if (existingId) {
      const existing = this.activeDownloads.find((d) => d.id === existingId);
      if (existing) {
        downloadStatus = existing;
        downloadStatus.status = "downloading";
        downloadStatus.error = void 0;
      } else {
        return;
      }
    } else {
      downloadStatus = {
        id: downloadId,
        name: link,
        progress: "0%",
        speed: "0",
        eta: "?",
        status: "downloading",
        params: { url: link, quality, type }
      };
      this.activeDownloads.push(downloadStatus);
    }
    (_a = this.listView) == null ? void 0 : _a.updateDownloadProgress();
    let args = [
      link,
      "-o",
      "%(title)s.%(ext)s",
      "--no-playlist",
      "--newline"
    ];
    if (ffmpegPath) {
      args.push("--ffmpeg-location", ffmpegPath);
    }
    if (type === "audio") {
      args.push("-x", "--audio-format", "mp3");
    } else {
      if (quality === "best") {
        args.push("-f", "bestvideo+bestaudio/best");
      } else if (quality === "1080p") {
        args.push("-f", "bestvideo[height<=1080]+bestaudio/best[height<=1080]");
      } else if (quality === "720p") {
        args.push("-f", "bestvideo[height<=720]+bestaudio/best[height<=720]");
      } else if (quality === "480p") {
        args.push("-f", "bestvideo[height<=480]+bestaudio/best[height<=480]");
      }
      args.push("--merge-output-format", "mp4");
    }
    try {
      const { spawn } = require("child_process");
      console.log(`Spawning: ${ytPath} ${args.join(" ")}`);
      const child = spawn(ytPath, args, { cwd });
      downloadStatus.childProcess = child;
      child.stdout.on("data", (data) => {
        var _a2, _b2, _c;
        const lines = data.toString().split("\n");
        for (const line of lines) {
          if (line.includes("[download]")) {
            const percentMatch = line.match(/(\d+\.\d+)%/);
            const speedMatch = line.match(/at\s+([^\s]+)/);
            const etaMatch = line.match(/ETA\s+([^\s]+)/);
            if (percentMatch) {
              let percent = parseFloat(percentMatch[1]);
              if (type === "audio") {
                percent = percent * 0.9;
              }
              downloadStatus.progress = percent.toFixed(1) + "%";
            }
            if (speedMatch) {
              downloadStatus.speed = speedMatch[1];
            }
            if (etaMatch) {
              downloadStatus.eta = etaMatch[1];
            }
            (_a2 = this.listView) == null ? void 0 : _a2.updateDownloadProgress();
          }
          if (line.includes("[download] Destination:")) {
            const name = line.split("Destination:")[1].trim();
            downloadStatus.name = name;
            (_b2 = this.listView) == null ? void 0 : _b2.updateDownloadProgress();
          }
          if (line.includes("[ExtractAudio]") || line.includes("[ffmpeg]") || line.includes("[Merger]")) {
            downloadStatus.status = "converting";
            downloadStatus.progress = "95%";
            (_c = this.listView) == null ? void 0 : _c.updateDownloadProgress();
          }
        }
      });
      child.stderr.on("data", (data) => {
        var _a2;
        const errorMsg = data.toString();
        console.error(`yt-dlp stderr: ${errorMsg}`);
        if (errorMsg.includes("HTTP Error 400") || errorMsg.includes("Precondition check failed") || errorMsg.includes("Unable to extract")) {
          downloadStatus.error = "Update yt-dlp!";
          downloadStatus.status = "error";
          (_a2 = this.listView) == null ? void 0 : _a2.updateDownloadProgress();
        } else if (errorMsg.includes("ffmpeg-location") && errorMsg.includes("does not exist")) {
          console.warn("FFmpeg path invalid");
        }
      });
      child.on("error", (err) => {
        var _a2;
        console.error("Failed to start process", err);
        downloadStatus.status = "error";
        downloadStatus.error = err.message;
        (_a2 = this.listView) == null ? void 0 : _a2.updateDownloadProgress();
      });
      child.on("close", (code) => {
        var _a2;
        if (code === 0) {
          downloadStatus.status = "completed";
          downloadStatus.progress = "100%";
          const { watchedFolder, downloadFolder } = this.data.settings;
          const targetFolder = downloadFolder || watchedFolder;
          if (targetFolder === watchedFolder) {
            this.scanFolder(watchedFolder);
          }
        } else if (downloadStatus.status !== "paused" && code !== null) {
          downloadStatus.status = "error";
          downloadStatus.error = `Exit code ${code}`;
        }
        downloadStatus.childProcess = void 0;
        (_a2 = this.listView) == null ? void 0 : _a2.updateDownloadProgress();
        if (downloadStatus.status === "completed") {
          setTimeout(() => {
            var _a3;
            this.activeDownloads = this.activeDownloads.filter((d) => d.id !== downloadId);
            (_a3 = this.listView) == null ? void 0 : _a3.updateDownloadProgress();
          }, 5e3);
        }
      });
    } catch (e) {
      console.error("Download failed", e);
      new import_obsidian.Notice(`Failed to download: ${link}`);
      downloadStatus.status = "error";
      downloadStatus.error = "Failed to start";
      (_b = this.listView) == null ? void 0 : _b.updateDownloadProgress();
    }
  }
  cancelDownload(id) {
    var _a;
    const dl = this.activeDownloads.find((d) => d.id === id);
    if (dl) {
      if (dl.childProcess) {
        dl.childProcess.kill();
      }
      this.activeDownloads = this.activeDownloads.filter((d) => d.id !== id);
      (_a = this.listView) == null ? void 0 : _a.updateDownloadProgress();
      new import_obsidian.Notice("Download cancelled");
    }
  }
  pauseDownload(id) {
    var _a;
    const dl = this.activeDownloads.find((d) => d.id === id);
    if (dl && dl.childProcess) {
      dl.status = "paused";
      dl.childProcess.kill();
      (_a = this.listView) == null ? void 0 : _a.updateDownloadProgress();
    }
  }
  resumeDownload(id) {
    if (!import_obsidian.Platform.isDesktop)
      return;
    const path = require("path");
    const dl = this.activeDownloads.find((d) => d.id === id);
    if (dl && dl.params) {
      const { downloadFolder, watchedFolder } = this.data.settings;
      const targetFolder = downloadFolder || watchedFolder;
      const adapter = this.app.vault.adapter;
      let absolutePath = "";
      if (adapter instanceof Object && "getBasePath" in adapter) {
        absolutePath = path.join(adapter.getBasePath(), targetFolder);
      }
      if (absolutePath) {
        this.startDownload(dl.params.url, dl.params.quality, dl.params.type, absolutePath, id);
      }
    }
  }
};
var YouTubeDownloadModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.videoLinks = "";
    this.audioLinks = "";
    this.plugin = plugin;
    this.quality = "best";
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Download from YouTube" });
    new import_obsidian.Setting(contentEl).setName("Video Links").setDesc("Paste links to download as VIDEO (with audio), one per line.").addTextArea((text) => text.setPlaceholder("https://youtube.com/watch?v=...").setValue(this.videoLinks).onChange(async (value) => {
      this.videoLinks = value;
    }));
    const textareas = contentEl.querySelectorAll("textarea");
    if (textareas.length > 0) {
      const videoArea = textareas[0];
      videoArea.style.height = "100px";
      videoArea.style.width = "100%";
    }
    new import_obsidian.Setting(contentEl).setName("Audio Links").setDesc("Paste links to download as AUDIO ONLY (mp3), one per line.").addTextArea((text) => text.setPlaceholder("https://youtube.com/watch?v=...").setValue(this.audioLinks).onChange(async (value) => {
      this.audioLinks = value;
    }));
    if (textareas.length > 1) {
    }
    const allTextareas = contentEl.querySelectorAll("textarea");
    allTextareas.forEach((ta) => {
      ta.style.height = "100px";
      ta.style.width = "100%";
    });
    new import_obsidian.Setting(contentEl).setName("Quality").setDesc("Select max video quality (ignored for audio links).").addDropdown((drop3) => drop3.addOption("best", "Best Available").addOption("1080p", "1080p").addOption("720p", "720p").addOption("480p", "480p").setValue(this.quality).onChange(async (value) => {
      this.quality = value;
    }));
    new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("Download All").setCta().onClick(() => {
      const videoList = this.videoLinks.split("\n").filter((l) => l.trim().length > 0);
      const audioList = this.audioLinks.split("\n").filter((l) => l.trim().length > 0);
      if (videoList.length === 0 && audioList.length === 0) {
        new import_obsidian.Notice("Please enter at least one link.");
        return;
      }
      if (videoList.length > 0) {
        this.plugin.downloadVideos(videoList, this.quality, "video");
      }
      if (audioList.length > 0) {
        this.plugin.downloadVideos(audioList, this.quality, "audio");
      }
      this.close();
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var FolderSuggestModal = class extends import_obsidian.FuzzySuggestModal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  getItems() {
    return this.app.vault.getAllLoadedFiles().filter((f) => f instanceof import_obsidian.TFolder);
  }
  getItemText(item) {
    return item.path;
  }
  onChooseItem(item) {
    this.plugin.setWatchedFolder(item.path);
  }
};
var CrossPlayerSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h3", { text: "General Settings" });
    new import_obsidian.Setting(containerEl).setName("Watched Folder").setDesc("Current watched folder path (relative to vault root).").addText((text) => text.setPlaceholder("No folder set").setValue(this.plugin.data.settings.watchedFolder).setDisabled(true)).addButton((button) => button.setButtonText("Set Watched Folder").onClick(() => {
      new FolderSuggestModal(this.app, this.plugin).open();
    }));
    new import_obsidian.Setting(containerEl).setName("Default Playback Speed").setDesc("The default speed when the player starts or resets.").addSlider((slider) => slider.setLimits(0.5, 5, 0.1).setValue(this.plugin.data.settings.defaultPlaybackSpeed).setDynamicTooltip().onChange(async (value) => {
      this.plugin.data.settings.defaultPlaybackSpeed = value;
      await this.plugin.saveData();
    }));
    new import_obsidian.Setting(containerEl).setName("Seek Forward Seconds").setDesc("Number of seconds to seek forward.").addText((text) => text.setValue(String(this.plugin.data.settings.seekSecondsForward)).onChange(async (value) => {
      const parsed = parseInt(value);
      if (!isNaN(parsed) && parsed > 0) {
        this.plugin.data.settings.seekSecondsForward = parsed;
        await this.plugin.saveData();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Seek Backward Seconds").setDesc("Number of seconds to seek backward.").addText((text) => text.setValue(String(this.plugin.data.settings.seekSecondsBackward)).onChange(async (value) => {
      const parsed = parseInt(value);
      if (!isNaN(parsed) && parsed > 0) {
        this.plugin.data.settings.seekSecondsBackward = parsed;
        await this.plugin.saveData();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Show Media Indicator").setDesc("Show audio/video icon in the queue list.").addToggle((toggle) => toggle.setValue(this.plugin.data.settings.showMediaIndicator).onChange(async (value) => {
      this.plugin.data.settings.showMediaIndicator = value;
      await this.plugin.saveData();
    }));
    new import_obsidian.Setting(containerEl).setName("Show Progress Color in Queue").setDesc("Color the queue items based on playback progress.").addToggle((toggle) => toggle.setValue(this.plugin.data.settings.showProgressColor).onChange(async (value) => {
      var _a;
      this.plugin.data.settings.showProgressColor = value;
      await this.plugin.saveData();
      (_a = this.plugin.listView) == null ? void 0 : _a.refresh();
    }));
    new import_obsidian.Setting(containerEl).setName("Autoplay Next Video").setDesc("Automatically play the next video in the queue when the current one finishes.").addToggle((toggle) => toggle.setValue(this.plugin.data.settings.autoplayNext).onChange(async (value) => {
      this.plugin.data.settings.autoplayNext = value;
      await this.plugin.saveData();
    }));
    new import_obsidian.Setting(containerEl).setName("Pause on Mobile Tap").setDesc("Pause the player when tapping the video on mobile. If disabled, tapping only shows controls.").addToggle((toggle) => toggle.setValue(this.plugin.data.settings.pauseOnMobileTap).onChange(async (value) => {
      this.plugin.data.settings.pauseOnMobileTap = value;
      await this.plugin.saveData();
    }));
    containerEl.createEl("h3", { text: "Storage & Download Settings" });
    new import_obsidian.Setting(containerEl).setName("yt-dlp Binary Path").setDesc('Absolute path to yt-dlp executable (or just "yt-dlp" if in PATH).').addText((text) => text.setValue(this.plugin.data.settings.youtubeDlpPath).onChange(async (value) => {
      this.plugin.data.settings.youtubeDlpPath = value;
      await this.plugin.saveData();
    }));
    new import_obsidian.Setting(containerEl).setName("FFmpeg Binary Path").setDesc("Absolute path to ffmpeg executable (optional, if not in PATH). Auto-detected if ffmpeg-static is installed.").addText((text) => text.setValue(this.plugin.data.settings.ffmpegPath).onChange(async (value) => {
      this.plugin.data.settings.ffmpegPath = value;
      await this.plugin.saveData();
    }));
    new import_obsidian.Setting(containerEl).setName("Download Folder").setDesc("Folder to save downloads (relative to vault). Leave empty to use Watched Folder.").addText((text) => text.setValue(this.plugin.data.settings.downloadFolder).onChange(async (value) => {
      this.plugin.data.settings.downloadFolder = value;
      await this.plugin.saveData();
    }));
    new import_obsidian.Setting(containerEl).setName("Storage Limit (GB)").setDesc("Manual storage limit in Gigabytes.").addText((text) => text.setPlaceholder("10").setValue(String(this.plugin.data.settings.storageLimitGB || 10)).onChange(async (value) => {
      const limit = parseFloat(value);
      if (!isNaN(limit) && limit > 0) {
        this.plugin.data.settings.storageLimitGB = limit;
        await this.plugin.saveData();
        this.plugin.calculateDynamicLimit();
      }
    }));
  }
};
var CrossPlayerListView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_CROSS_PLAYER_LIST;
  }
  getDisplayText() {
    return "Cross Player Queue";
  }
  getIcon() {
    return "list-video";
  }
  async onOpen() {
    this.refresh();
  }
  refresh() {
    const container = this.contentEl;
    container.empty();
    container.style.display = "flex";
    container.style.flexDirection = "column";
    container.style.height = "100%";
    container.style.overflow = "hidden";
    const headerContainer = container.createDiv({ cls: "cross-player-header" });
    headerContainer.style.textAlign = "center";
    headerContainer.style.marginBottom = "10px";
    headerContainer.style.flexShrink = "0";
    const titleRow = headerContainer.createDiv({ cls: "cross-player-title-row" });
    titleRow.style.display = "flex";
    titleRow.style.justifyContent = "center";
    titleRow.style.alignItems = "center";
    titleRow.style.gap = "8px";
    titleRow.createEl("h4", { text: "Media Queue", cls: "cross-player-title", attr: { style: "margin: 0;" } });
    const sortBtn = titleRow.createDiv({ cls: "clickable-icon" });
    (0, import_obsidian.setIcon)(sortBtn, "arrow-up-down");
    sortBtn.ariaLabel = "Sort Queue";
    sortBtn.onclick = (evt) => {
      const menu = new import_obsidian.Menu();
      menu.addItem((item) => item.setTitle("Name (A to Z)").setIcon("sort-asc").onClick(() => this.plugin.sortQueue("name", "asc")));
      menu.addItem((item) => item.setTitle("Name (Z to A)").setIcon("sort-desc").onClick(() => this.plugin.sortQueue("name", "desc")));
      menu.addSeparator();
      menu.addItem((item) => item.setTitle("Type (A to Z)").setIcon("file").onClick(() => this.plugin.sortQueue("type", "asc")));
      menu.addItem((item) => item.setTitle("Type (Z to A)").setIcon("file").onClick(() => this.plugin.sortQueue("type", "desc")));
      menu.addSeparator();
      menu.addItem((item) => item.setTitle("Size (Smallest)").setIcon("chevrons-down").onClick(() => this.plugin.sortQueue("size", "asc")));
      menu.addItem((item) => item.setTitle("Size (Largest)").setIcon("chevrons-up").onClick(() => this.plugin.sortQueue("size", "desc")));
      menu.showAtMouseEvent(evt);
    };
    const refreshBtn = titleRow.createDiv({ cls: "clickable-icon" });
    (0, import_obsidian.setIcon)(refreshBtn, "refresh-cw");
    refreshBtn.ariaLabel = "Refresh Data";
    refreshBtn.onclick = async () => {
      await this.plugin.loadData();
      this.refresh();
      new import_obsidian.Notice("Data reloaded.");
    };
    const speed = this.plugin.data.playbackSpeed || 1;
    const speedEl = headerContainer.createDiv({ cls: "cross-player-speed-display" });
    speedEl.setText(`Speed: ${speed.toFixed(1)}x`);
    speedEl.style.fontSize = "0.8em";
    speedEl.style.color = "var(--text-muted)";
    const stats = this.plugin.getQueueStats();
    const adjustedDuration = stats.totalDuration / speed;
    const limitBytes = this.plugin.dynamicStorageLimit;
    const limitGB = limitBytes > 0 ? limitBytes / (1024 * 1024 * 1024) : 10;
    const sizeInGB = stats.totalSize / (1024 * 1024 * 1024);
    const statsContainer = headerContainer.createDiv({ cls: "cross-player-stats" });
    statsContainer.style.fontSize = "0.8em";
    statsContainer.style.color = "var(--text-muted)";
    statsContainer.style.marginTop = "5px";
    const etcText = `ETC: ${this.formatDuration(adjustedDuration)}`;
    statsContainer.createSpan({ text: etcText });
    statsContainer.createSpan({ text: " \u2022 " });
    const sizeSpan = statsContainer.createSpan({ text: `Size: ${sizeInGB.toFixed(2)} GB / ${limitGB.toFixed(1)} GB` });
    if (sizeInGB > limitGB) {
      sizeSpan.style.color = "var(--text-error)";
      sizeSpan.style.fontWeight = "bold";
    }
    const list = container.createDiv({ cls: "cross-player-list" });
    list.style.flexGrow = "1";
    list.style.overflowY = "auto";
    list.style.overflowX = "hidden";
    this.plugin.data.queue.forEach((item) => {
      var _a;
      const itemEl = list.createDiv({ cls: "cross-player-item" });
      itemEl.dataset.id = item.id;
      itemEl.style.display = "flex";
      itemEl.style.alignItems = "center";
      itemEl.style.padding = "5px";
      itemEl.style.borderBottom = "1px solid var(--background-modifier-border)";
      if (item.status === "playing") {
        itemEl.style.backgroundColor = "var(--background-modifier-active-hover)";
      }
      if (this.plugin.data.settings.showProgressColor && item.duration > 0 && item.position > 0) {
        const pct = Math.min(100, item.position / item.duration * 100);
        const color = `color-mix(in srgb, var(--interactive-accent), transparent 80%)`;
        itemEl.style.backgroundImage = `linear-gradient(to right, ${color} ${pct}%, transparent ${pct}%)`;
        itemEl.style.backgroundSize = "100% 100%";
        itemEl.style.backgroundRepeat = "no-repeat";
      }
      const statusIcon = itemEl.createDiv({ cls: "cross-player-status-icon" });
      if (item.status === "completed")
        (0, import_obsidian.setIcon)(statusIcon, "check-circle");
      else if (item.status === "playing")
        (0, import_obsidian.setIcon)(statusIcon, "play-circle");
      else
        (0, import_obsidian.setIcon)(statusIcon, "circle");
      statusIcon.style.marginRight = "5px";
      if (this.plugin.data.settings.showMediaIndicator) {
        const typeIcon = itemEl.createDiv({ cls: "cross-player-type-icon" });
        const ext = (_a = item.path.split(".").pop()) == null ? void 0 : _a.toLowerCase();
        const isAudio = ["mp3", "wav", "ogg"].includes(ext || "");
        (0, import_obsidian.setIcon)(typeIcon, isAudio ? "headphones" : "film");
        typeIcon.style.marginRight = "10px";
        typeIcon.style.color = "var(--text-muted)";
      }
      const nameEl = itemEl.createDiv({ text: item.name, cls: "cross-player-name" });
      nameEl.style.flexGrow = "1";
      nameEl.style.overflow = "hidden";
      nameEl.style.textOverflow = "ellipsis";
      nameEl.style.whiteSpace = "nowrap";
      nameEl.style.cursor = "pointer";
      nameEl.title = item.path;
      nameEl.addEventListener("click", (e) => {
        e.stopPropagation();
        this.plugin.playMedia(item, true);
      });
      itemEl.addEventListener("contextmenu", (event) => {
        event.preventDefault();
        event.stopPropagation();
        const menu = new import_obsidian.Menu();
        menu.addItem(
          (menuItem) => menuItem.setTitle("Delete Media").setIcon("trash").onClick(() => {
            this.plugin.deleteMediaItem(item);
          })
        );
        menu.addItem(
          (menuItem) => menuItem.setTitle("Set as Unread").setIcon("undo").onClick(() => {
            this.plugin.setMediaItemAsUnread(item);
          })
        );
        menu.showAtPosition({ x: event.clientX, y: event.clientY });
      });
      const controls = itemEl.createDiv({ cls: "cross-player-controls" });
      controls.style.display = "flex";
      controls.style.gap = "5px";
      const handle = controls.createDiv({ cls: "clickable-icon sortable-handle" });
      (0, import_obsidian.setIcon)(handle, "grip-horizontal");
      handle.style.cursor = "grab";
    });
    sortable_esm_default.create(list, {
      animation: 150,
      handle: ".sortable-handle",
      ghostClass: "sortable-ghost",
      // Disable forceFallback to use native DnD (fixes mobile offset issues)
      forceFallback: false,
      delay: 100,
      // Short delay to prevent accidental scrolling interference
      delayOnTouchOnly: true,
      touchStartThreshold: 5,
      onSort: async (evt) => {
        if (evt.oldIndex !== void 0 && evt.newIndex !== void 0) {
          await this.plugin.reorderItem(evt.oldIndex, evt.newIndex);
        }
      }
    });
    const downloadContainer = container.createDiv({ cls: "cross-player-download-container" });
    downloadContainer.style.flexShrink = "0";
    downloadContainer.style.borderTop = "1px solid var(--background-modifier-border)";
    downloadContainer.style.backgroundColor = "var(--background-secondary)";
    this.updateDownloadProgress(downloadContainer);
  }
  updateStats() {
    const statsContainer = this.contentEl.querySelector(".cross-player-stats");
    if (!statsContainer)
      return;
    const speed = this.plugin.data.playbackSpeed || 1;
    const stats = this.plugin.getQueueStats();
    const adjustedDuration = stats.totalDuration / speed;
    const limitBytes = this.plugin.dynamicStorageLimit;
    const limitGB = limitBytes > 0 ? limitBytes / (1024 * 1024 * 1024) : 10;
    const sizeInGB = stats.totalSize / (1024 * 1024 * 1024);
    statsContainer.empty();
    const etcText = `ETC: ${this.formatDuration(adjustedDuration)}`;
    statsContainer.createSpan({ text: etcText });
    statsContainer.createSpan({ text: " \u2022 " });
    const sizeSpan = statsContainer.createSpan({ text: `Size: ${sizeInGB.toFixed(2)} GB / ${limitGB.toFixed(1)} GB` });
    if (sizeInGB > limitGB) {
      sizeSpan.style.color = "var(--text-error)";
      sizeSpan.style.fontWeight = "bold";
    }
  }
  updateItemProgress(id, percentage) {
    if (!this.plugin.data.settings.showProgressColor)
      return;
    const itemEl = this.contentEl.querySelector(`.cross-player-item[data-id="${id}"]`);
    if (itemEl) {
      const pct = Math.min(100, Math.max(0, percentage));
      const color = `color-mix(in srgb, var(--interactive-accent), transparent 80%)`;
      itemEl.style.backgroundImage = `linear-gradient(to right, ${color} ${pct}%, transparent ${pct}%)`;
    }
  }
  updateDownloadProgress(parentContainer) {
    let container = parentContainer;
    if (!container) {
      container = this.contentEl.querySelector(".cross-player-download-container");
    }
    if (!container)
      return;
    container.empty();
    const activeDownloads = this.plugin.activeDownloads;
    if (activeDownloads.length === 0) {
      container.style.display = "none";
      return;
    } else {
      container.style.display = "block";
    }
    const header = container.createDiv({ cls: "download-header" });
    header.style.padding = "5px 10px";
    header.style.cursor = "pointer";
    header.style.display = "flex";
    header.style.justifyContent = "space-between";
    header.style.alignItems = "center";
    header.style.backgroundColor = "var(--background-secondary-alt)";
    header.createSpan({ text: `Downloads (${activeDownloads.length})`, attr: { style: "font-weight: bold; font-size: 0.9em;" } });
    const toggleIcon = header.createDiv();
    const isCollapsed = container.dataset.collapsed === "true";
    (0, import_obsidian.setIcon)(toggleIcon, isCollapsed ? "chevron-up" : "chevron-down");
    const content = container.createDiv({ cls: "download-content" });
    content.style.padding = "10px";
    content.style.maxHeight = "30vh";
    content.style.overflowY = "auto";
    if (isCollapsed)
      content.style.display = "none";
    header.onclick = () => {
      const collapsed = container.dataset.collapsed === "true";
      container.dataset.collapsed = String(!collapsed);
      if (!collapsed) {
        content.style.display = "none";
        (0, import_obsidian.setIcon)(toggleIcon, "chevron-up");
      } else {
        content.style.display = "block";
        (0, import_obsidian.setIcon)(toggleIcon, "chevron-down");
      }
    };
    if (activeDownloads.length > 0) {
      let totalProgress = 0;
      let count = 0;
      activeDownloads.forEach((d) => {
        if (d.status === "completed") {
          totalProgress += 100;
          count++;
        } else if (d.progress.includes("%")) {
          totalProgress += parseFloat(d.progress) || 0;
          count++;
        } else if (d.status === "downloading" || d.status === "paused") {
          count++;
        }
      });
      const avgProgress = count > 0 ? totalProgress / count : 0;
      const globalProgressContainer = content.createDiv({ attr: { style: "margin-bottom: 10px;" } });
      globalProgressContainer.createDiv({ text: `Total Progress: ${avgProgress.toFixed(1)}%`, attr: { style: "font-size: 0.8em; margin-bottom: 2px; color: var(--text-muted);" } });
      const globalBar = globalProgressContainer.createEl("progress");
      globalBar.style.width = "100%";
      globalBar.style.height = "8px";
      globalBar.value = avgProgress;
      globalBar.max = 100;
    }
    activeDownloads.forEach((dl) => {
      const dlItem = content.createDiv({ cls: "download-item" });
      dlItem.style.marginBottom = "8px";
      dlItem.style.fontSize = "0.8em";
      dlItem.style.borderBottom = "1px solid var(--background-modifier-border)";
      dlItem.style.paddingBottom = "5px";
      const nameRow = dlItem.createDiv({ attr: { style: "display: flex; justify-content: space-between; margin-bottom: 2px;" } });
      nameRow.createSpan({ text: dl.name, attr: { style: "overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 70%; font-weight: bold;" } });
      let statusText = dl.progress;
      if (dl.status === "error")
        statusText = "Error";
      else if (dl.status === "paused")
        statusText = "Paused";
      else if (dl.status === "converting")
        statusText = "Converting...";
      nameRow.createSpan({ text: statusText });
      const progressBar = dlItem.createEl("progress");
      progressBar.style.width = "100%";
      progressBar.style.height = "6px";
      if (dl.progress.includes("%")) {
        progressBar.value = parseFloat(dl.progress) || 0;
      } else {
        progressBar.value = 0;
      }
      progressBar.max = 100;
      const controlsRow = dlItem.createDiv({ attr: { style: "display: flex; justify-content: space-between; align-items: center; margin-top: 2px;" } });
      const info = controlsRow.createDiv({ attr: { style: "color: var(--text-muted); font-size: 0.9em;" } });
      if (dl.status === "downloading") {
        info.setText(`${dl.speed} - ETA: ${dl.eta}`);
      } else if (dl.status === "converting") {
        info.setText("Processing media...");
      } else if (dl.status === "error") {
        info.setText(dl.error || "Unknown Error");
        info.style.color = "var(--text-error)";
      }
      const btnGroup = controlsRow.createDiv({ attr: { style: "display: flex; gap: 5px;" } });
      if (dl.status === "downloading") {
        const pauseBtn = btnGroup.createEl("button", { text: "Pause" });
        pauseBtn.style.fontSize = "0.8em";
        pauseBtn.style.padding = "2px 5px";
        pauseBtn.onclick = () => this.plugin.pauseDownload(dl.id);
      } else if (dl.status === "paused") {
        const resumeBtn = btnGroup.createEl("button", { text: "Resume" });
        resumeBtn.style.fontSize = "0.8em";
        resumeBtn.style.padding = "2px 5px";
        resumeBtn.onclick = () => this.plugin.resumeDownload(dl.id);
      }
      const cancelBtn = btnGroup.createEl("button", { text: "Cancel" });
      cancelBtn.style.fontSize = "0.8em";
      cancelBtn.style.padding = "2px 5px";
      cancelBtn.onclick = () => this.plugin.cancelDownload(dl.id);
    });
  }
  updateSpeedDisplay() {
    const speedEl = this.contentEl.querySelector(".cross-player-speed-display");
    if (speedEl) {
      const speed = this.plugin.data.playbackSpeed || 1;
      speedEl.setText(`Speed: ${speed.toFixed(1)}x`);
      this.refresh();
    }
  }
  formatDuration(seconds) {
    if (!seconds || isNaN(seconds))
      return "0s";
    const h = Math.floor(seconds / 3600);
    const m = Math.floor(seconds % 3600 / 60);
    const s = Math.floor(seconds % 60);
    if (h > 0)
      return `${h}h ${m}m ${s}s`;
    return `${m}m ${s}s`;
  }
};
var CrossPlayerMainView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    // Added wrapper property
    this.overlayEl = null;
    this.audioPlaceholderEl = null;
    this.currentItem = null;
    this.lastEtcUpdate = 0;
    this.lastProgressUpdate = 0;
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_CROSS_PLAYER_MAIN;
  }
  getDisplayText() {
    return this.currentItem ? this.currentItem.name : "Cross Player";
  }
  getIcon() {
    return "play";
  }
  async onOpen() {
    const container = this.contentEl;
    container.empty();
    container.addClass("cross-player-main-view");
    container.tabIndex = 0;
    container.style.outline = "none";
    container.addEventListener("keydown", (e) => {
      if (!this.videoEl)
        return;
      if (document.activeElement === this.videoEl)
        return;
      if (["INPUT", "TEXTAREA"].includes(e.target.tagName))
        return;
      const { seekSecondsForward, seekSecondsBackward } = this.plugin.data.settings;
      switch (e.key) {
        case " ":
        case "Spacebar":
          e.preventDefault();
          if (this.videoEl.paused) {
            this.videoEl.play();
          } else {
            this.videoEl.pause();
          }
          break;
        case "ArrowRight":
          e.preventDefault();
          this.videoEl.currentTime = Math.min(this.videoEl.duration, this.videoEl.currentTime + seekSecondsForward);
          break;
        case "ArrowLeft":
          e.preventDefault();
          this.videoEl.currentTime = Math.max(0, this.videoEl.currentTime - seekSecondsBackward);
          break;
      }
    });
    container.style.display = "flex";
    container.style.flexDirection = "column";
    container.style.justifyContent = "center";
    container.style.alignItems = "center";
    container.style.height = "100%";
    container.style.backgroundColor = "#000";
    container.style.position = "relative";
    this.videoWrapperEl = container.createDiv({ cls: "cross-player-video-wrapper" });
    this.videoWrapperEl.style.position = "relative";
    this.videoWrapperEl.style.width = "100%";
    this.videoWrapperEl.style.height = "100%";
    this.videoWrapperEl.style.display = "flex";
    this.videoWrapperEl.style.justifyContent = "center";
    this.videoWrapperEl.style.alignItems = "center";
    this.videoEl = this.videoWrapperEl.createEl("video");
    this.videoEl.controls = true;
    this.videoEl.style.maxWidth = "100%";
    this.videoEl.style.maxHeight = "100%";
    this.videoEl.style.width = "100%";
    this.videoEl.style.height = "100%";
    this.refreshMobileOverlay();
    this.videoEl.onended = async () => {
      if (this.currentItem) {
        if (this.currentItem.status !== "completed") {
          await this.plugin.updateStatus(this.currentItem.id, "completed");
          if (this.plugin.data.settings.autoplayNext) {
            this.plugin.playNextUnread();
          }
        }
      }
    };
    this.videoEl.ontimeupdate = async () => {
      if (this.currentItem) {
        this.currentItem.position = this.videoEl.currentTime;
        const now = Date.now();
        if (now - this.lastEtcUpdate > 5e3) {
          this.lastEtcUpdate = now;
          if (this.plugin.listView) {
            this.plugin.listView.updateStats();
          }
        }
        if (now - this.lastProgressUpdate > 1e3) {
          this.lastProgressUpdate = now;
          if (this.plugin.listView && this.plugin.data.settings.showProgressColor && this.videoEl.duration > 0) {
            const pct = this.videoEl.currentTime / this.videoEl.duration * 100;
            this.plugin.listView.updateItemProgress(this.currentItem.id, pct);
          }
        }
        if (this.currentItem.status !== "completed" && this.videoEl.duration > 0) {
          const progress = this.videoEl.currentTime / this.videoEl.duration;
          if (progress > 0.95) {
            await this.plugin.updateStatus(this.currentItem.id, "completed");
          }
        }
      }
    };
    this.videoEl.onpause = async () => {
      if (this.currentItem) {
        await this.plugin.updatePosition(this.currentItem.id, this.videoEl.currentTime);
      }
    };
  }
  refreshMobileOverlay() {
    const container = this.contentEl;
    const shouldShow = import_obsidian.Platform.isMobile;
    if (!shouldShow) {
      if (this.overlayEl) {
        this.overlayEl.remove();
        this.overlayEl = null;
      }
      return;
    }
    if (!this.overlayEl || !container.contains(this.overlayEl)) {
      if (this.overlayEl) {
        this.overlayEl.remove();
      }
      this.createMobileOverlay(container);
    }
  }
  createMobileOverlay(container) {
    const overlay = container.createDiv({ cls: "cross-player-overlay" });
    this.overlayEl = overlay;
    overlay.style.position = "absolute";
    overlay.style.top = "0";
    overlay.style.left = "0";
    overlay.style.width = "100%";
    overlay.style.height = "100%";
    overlay.style.display = "flex";
    overlay.style.flexDirection = "column";
    overlay.style.justifyContent = "center";
    overlay.style.alignItems = "center";
    overlay.style.backgroundColor = "rgba(0, 0, 0, 0.4)";
    overlay.style.zIndex = "10";
    overlay.style.opacity = "0";
    overlay.style.transition = "opacity 0.3s ease";
    overlay.style.pointerEvents = "none";
    let hideTimeout;
    const showOverlay = () => {
      overlay.style.opacity = "1";
      overlay.style.pointerEvents = "auto";
      if (hideTimeout)
        clearTimeout(hideTimeout);
      hideTimeout = setTimeout(() => {
        overlay.style.opacity = "0";
        overlay.style.pointerEvents = "none";
      }, 3e3);
    };
    const hideOverlay = () => {
      overlay.style.opacity = "0";
      overlay.style.pointerEvents = "none";
      if (hideTimeout)
        clearTimeout(hideTimeout);
    };
    let touchStartTime = 0;
    let touchStartX = 0;
    let touchStartY = 0;
    let isScrolling = false;
    const onTouchStart = (e) => {
      touchStartTime = Date.now();
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
      isScrolling = false;
    };
    const onTouchMove = (e) => {
      if (Math.abs(e.touches[0].clientX - touchStartX) > 10 || Math.abs(e.touches[0].clientY - touchStartY) > 10) {
        isScrolling = true;
      }
    };
    const onTouchEnd = (e) => {
      if (isScrolling)
        return;
      if (Date.now() - touchStartTime > 500)
        return;
      const target = e.target;
      const touchY = e.changedTouches[0].clientY;
      const rect = this.videoEl.getBoundingClientRect();
      if (overlay.style.opacity === "0") {
        const relativeY = touchY - rect.top;
        if (relativeY > rect.height - 50) {
          return;
        }
        e.preventDefault();
        e.stopPropagation();
        if (this.plugin.data.settings.pauseOnMobileTap) {
          if (!this.videoEl.paused) {
            this.videoEl.pause();
            const playBtn = overlay.querySelector(".play-btn");
            if (playBtn)
              (0, import_obsidian.setIcon)(playBtn, "play");
          }
        }
        showOverlay();
      } else {
        if (target.closest(".cross-player-big-btn")) {
          return;
        }
        e.preventDefault();
        e.stopPropagation();
        hideOverlay();
      }
    };
    container.addEventListener("touchstart", onTouchStart, { capture: true });
    container.addEventListener("touchmove", onTouchMove, { capture: true });
    container.addEventListener("touchend", onTouchEnd, { capture: true });
    if (this.videoEl) {
      this.videoEl.onclick = null;
    }
    const controlsRow = overlay.createDiv({ cls: "cross-player-controls-row" });
    controlsRow.style.display = "flex";
    controlsRow.style.gap = "15px";
    controlsRow.style.alignItems = "center";
    controlsRow.style.justifyContent = "center";
    controlsRow.style.padding = "0 10px";
    const prevBtn = controlsRow.createDiv({ cls: "cross-player-big-btn" });
    (0, import_obsidian.setIcon)(prevBtn, "skip-back");
    this.styleBigButton(prevBtn);
    prevBtn.onclick = (e) => {
      e.stopPropagation();
      this.plugin.playPreviousItem();
      showOverlay();
    };
    const seekBackBtn = controlsRow.createDiv({ cls: "cross-player-big-btn" });
    (0, import_obsidian.setIcon)(seekBackBtn, "rewind");
    this.styleBigButton(seekBackBtn);
    seekBackBtn.onclick = (e) => {
      e.stopPropagation();
      this.seek(-this.plugin.data.settings.seekSecondsBackward);
      showOverlay();
    };
    const playPauseBtn = controlsRow.createDiv({ cls: "cross-player-big-btn play-btn" });
    (0, import_obsidian.setIcon)(playPauseBtn, "pause");
    this.styleBigButton(playPauseBtn);
    playPauseBtn.onclick = (e) => {
      e.stopPropagation();
      if (this.videoEl.paused) {
        this.videoEl.play();
        (0, import_obsidian.setIcon)(playPauseBtn, "pause");
      } else {
        this.videoEl.pause();
        (0, import_obsidian.setIcon)(playPauseBtn, "play");
      }
      showOverlay();
    };
    this.videoEl.onplay = () => (0, import_obsidian.setIcon)(playPauseBtn, "pause");
    this.videoEl.onpause = () => (0, import_obsidian.setIcon)(playPauseBtn, "play");
    const seekFwdBtn = controlsRow.createDiv({ cls: "cross-player-big-btn" });
    (0, import_obsidian.setIcon)(seekFwdBtn, "fast-forward");
    this.styleBigButton(seekFwdBtn);
    seekFwdBtn.onclick = (e) => {
      e.stopPropagation();
      this.seek(this.plugin.data.settings.seekSecondsForward);
      showOverlay();
    };
    const nextBtn = controlsRow.createDiv({ cls: "cross-player-big-btn" });
    (0, import_obsidian.setIcon)(nextBtn, "skip-forward");
    this.styleBigButton(nextBtn);
    nextBtn.onclick = (e) => {
      e.stopPropagation();
      this.plugin.playNextItem();
      showOverlay();
    };
  }
  styleBigButton(btn) {
    btn.addClass("cross-player-overlay-btn");
  }
  async play(item, autoPlay = false) {
    var _a;
    this.currentItem = item;
    if (this.leaf.view.headerTitleEl) {
      this.leaf.view.headerTitleEl.setText(item.name);
    } else {
      if (this.leaf.view.titleEl)
        this.leaf.view.titleEl.setText(item.name);
    }
    if (!this.videoEl) {
      const container = this.contentEl;
      this.videoEl = container.createEl("video");
      this.videoEl.controls = true;
      this.videoEl.style.maxWidth = "100%";
      this.videoEl.style.maxHeight = "100%";
      this.videoEl.style.width = "100%";
      this.videoEl.style.height = "100%";
    }
    const file = this.plugin.app.vault.getAbstractFileByPath(item.path);
    if (file instanceof import_obsidian.TFile) {
      this.videoEl.src = this.plugin.app.vault.getResourcePath(file);
    } else {
      console.error("File not found for playback:", item.path);
      return;
    }
    this.videoEl.currentTime = item.position || 0;
    this.videoEl.playbackRate = this.plugin.data.playbackSpeed || 1;
    const ext = (_a = item.path.split(".").pop()) == null ? void 0 : _a.toLowerCase();
    const isAudio = ["mp3", "wav", "ogg", "m4a", "aac"].includes(ext || "");
    if (isAudio) {
      if (!this.audioPlaceholderEl) {
        this.audioPlaceholderEl = this.contentEl.createDiv({ cls: "cross-player-audio-placeholder" });
        this.audioPlaceholderEl.style.position = "absolute";
        this.audioPlaceholderEl.style.top = "0";
        this.audioPlaceholderEl.style.left = "0";
        this.audioPlaceholderEl.style.width = "100%";
        this.audioPlaceholderEl.style.height = "100%";
        this.audioPlaceholderEl.style.display = "flex";
        this.audioPlaceholderEl.style.justifyContent = "center";
        this.audioPlaceholderEl.style.alignItems = "center";
        this.audioPlaceholderEl.style.zIndex = "1";
        this.audioPlaceholderEl.style.backgroundColor = "#1e1e1e";
      } else {
        this.audioPlaceholderEl.style.display = "flex";
        this.audioPlaceholderEl.empty();
      }
      this.videoEl.poster = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
      this.videoEl.style.height = "50px";
      this.videoEl.style.position = "absolute";
      this.videoEl.style.bottom = "0";
      this.videoEl.style.zIndex = "5";
      this.videoEl.style.background = "transparent";
    } else {
      if (this.audioPlaceholderEl) {
        this.audioPlaceholderEl.style.display = "none";
      }
      this.videoEl.poster = "";
      this.videoEl.style.background = "";
      this.videoEl.style.height = "100%";
      this.videoEl.style.position = "static";
      this.videoEl.style.zIndex = "auto";
    }
    if (autoPlay) {
      try {
        await this.videoEl.play();
      } catch (e) {
        console.error("Autoplay failed", e);
      }
    }
    this.refreshMobileOverlay();
  }
  async changePlaybackSpeed(delta) {
    if (!this.videoEl)
      return;
    const newSpeed = Math.max(0.1, this.videoEl.playbackRate + delta);
    this.videoEl.playbackRate = newSpeed;
    this.plugin.data.playbackSpeed = newSpeed;
    await this.plugin.saveData();
    if (this.plugin.listView) {
      this.plugin.listView.updateSpeedDisplay();
    }
  }
  seek(seconds) {
    if (!this.videoEl)
      return;
    const newTime = Math.max(0, Math.min(this.videoEl.duration, this.videoEl.currentTime + seconds));
    this.videoEl.currentTime = newTime;
  }
  toggleFullscreen() {
    if (!this.videoEl)
      return;
    if (!document.fullscreenElement) {
      this.contentEl.requestFullscreen().catch((err) => {
        new import_obsidian.Notice(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
      });
    } else {
      document.exitFullscreen();
    }
  }
};
/*! Bundled license information:

sortablejs/modular/sortable.esm.js:
  (**!
   * Sortable 1.15.6
   * @author	RubaXa   <trash@rubaxa.org>
   * @author	owenm    <owen23355@gmail.com>
   * @license MIT
   *)
*/
